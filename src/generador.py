# -*- coding: utf-8 -*-
"""generador.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1G5s-FKpoyrxeF8egQJCPQTn9YE3SGOlN
"""

# Funciones con las que generar los datos y estructuras iniciales en la simulación
import pandas as pd
import numpy as np
import random
import copy
from operator import itemgetter
import math

def establece_prioridad(numero_pacientes, max_prioridad):
  ESI = range(1,max_prioridad+1)
  probabilidades = [0.76, 11.26, 48.86, 37.16, 1.96]

  # Normalizar las probabilidades
  probabilidades_normalizadas = [p / sum(probabilidades) for p in probabilidades]

  array_prioridades = np.random.choice(ESI, numero_pacientes, p=probabilidades_normalizadas)
  return array_prioridades

def define_tepcof_paciente(prioridad, TEPCOF):
    valor=0
    if prioridad==1:
        valor=TEPCOF['1']

    elif prioridad==2:

        valor=TEPCOF['2']

    elif prioridad==3:
        valor=TEPCOF['3']

    elif prioridad==4:
        valor=TEPCOF['4']

    elif prioridad==5:
        valor=TEPCOF['5']

    return valor

def generar_pacientes_y_recursos(array_prioridades, procesos_por_prioridad, TEPCOF, tipos_recursos, recursos):
    pacientes = []
    recursos_ocupados = []
    PU_i = []
    matriz = []
    disponible = copy.copy(tipos_recursos)
    recursos_disponibles = copy.copy(recursos)
    pacientes_tipo_4 = 0
    act=0
    orden_actividades_por_paciente = {}

    ### Recorre paciente a paciente
    for paciente_id , prioridad in enumerate(array_prioridades,1):

      ## Asigna PU de procesos_por_prioridad
      PU_i = (procesos_por_prioridad[prioridad])

      TEPCOF_i = define_tepcof_paciente(prioridad, TEPCOF)

      tipo_paciente = random.choice([1, 2, 3, 4])




    ## Elige tipo_paciente // con todo lo que conlleva
    # Actualiza PU


      if tipo_paciente == 1:
          paciente = {
              "Paciente": int(paciente_id),
              "TEPCOF": TEPCOF_i,
              "Prioridad": prioridad,
              "t_llegada": 0,
              "visto": 0,
              "t_disponible": 0,
              "tipo_paciente":1,
              "PU": [sublista[0] for sublista in PU_i]
            }
      elif tipo_paciente == 2:
          t_llegada_max = TEPCOF_i * (1+(prioridad/5))
          t_llegada = math.ceil(random.uniform(1, t_llegada_max))

          paciente = {
              "Paciente": int(paciente_id),
              "TEPCOF": TEPCOF_i,
              "Prioridad": prioridad,
              "t_llegada": t_llegada,
              "visto": 0,
              "t_disponible": 0,
              "tipo_paciente":2,
              "PU": [sublista[0] for sublista in PU_i]
            }

      elif tipo_paciente == 3:

          PU_last = PU_i[:][:-1]
          punto_parada = random.choice(PU_last)
          indice_sublista = PU_i.index(punto_parada)

          # Crear la nueva lista a partir del índice encontrado
          nuevo_PU_i = PU_i[indice_sublista + 1:]
          #nuevo_PU_i = [actividad for actividad in PU_i if actividad >= recurso_elegido]

          PU_i = nuevo_PU_i

          paciente = {
              "Paciente": int(paciente_id),
              "TEPCOF": None,
              "Prioridad": prioridad,
              "t_llegada": None,
              "visto": 1,
              "t_disponible": 0,
              "tipo_paciente": 3,
              "PU": [sublista[0] for sublista in PU_i]
            }

      else:

            PU_last = PU_i[:][:-1]
            flag = 0

            # Elegimos una actividad que esté dentro del PU de ese paciente
            ## Falta algo para
            for i in range(0, len(PU_last)): # Vamos recorriendo actividad por actividad para ver si en alguna hay recursos dispo
                recurso_elegido = PU_last[i]
                if int(recurso_elegido[1]) <= int(disponible[recurso_elegido[0]]): # Si hay disponibles, deja de buscar
                    flag = 1
                    break

            if flag == 1: # Será un paciente de tipo 4
              pacientes_tipo_4 += 1
              # Encontrar el índice de la sublista en la lista original
              indice_sublista = PU_i.index(recurso_elegido)

              # Crear la nueva lista a partir del índice encontrado
              nuevo_PU_i = PU_i[indice_sublista + 1:]
              #nuevo_PU_i = [actividad for actividad in PU_i if actividad >= recurso_elegido]
              PU_i = nuevo_PU_i

              t_disponible = math.ceil(random.uniform(1, recurso_elegido[3])) # Poner algo en función del recurso que ocupa ?¿? poner mitad del tiempo de la actividad ¿?¿? EN ESE CASO ELEGIR ACTIVIDAD PRIMERO
              paciente = {
                "Paciente": int(paciente_id),
                "TEPCOF": None,
                "Prioridad": prioridad,
                "t_llegada": None,
                "visto": 1,
                "t_disponible": t_disponible,
                "tipo_paciente": 4,
                "PU": list(map(itemgetter(0), PU_i))
              }

              if not recurso_elegido[0].startswith('LAB'): # Si es LAB no 'bloqueamos' el recurso
                  disponible[recurso_elegido[0]] -= 1
                  # aqui toca especificar el recurso (CON1, CON2...)
                  for i in recursos_disponibles:
                      if i.startswith(recurso_elegido[0]):
                          recurso_ocupado = {
                            "recurso": i,
                            "t_disponible": t_disponible,
                            "TR": recurso_elegido[0]
                          }
                          recursos_disponibles.remove(i) #par el DF de recursos
                          recursos_ocupados.append(recurso_ocupado) # Para el DataFrame
                          break

            else: # si no hay recursos disponibles para ese paciente, será paciente de tipo 2
                  t_llegada_max = TEPCOF_i * (1+(prioridad/5))
                  t_llegada = random.uniform(1, t_llegada_max)

                  paciente = {
                      "Paciente": int(paciente_id),
                      "TEPCOF": TEPCOF_i,
                      "Prioridad": prioridad,
                      "t_llegada": t_llegada,
                      "visto": 0,
                      "t_disponible": 0,
                      "tipo_paciente":2,
                      "PU": list(map(itemgetter(0), PU_i))
                    }

      pacientes.append(paciente)

      # Establecemos tiempos actividades
      array_actividades = []
      for actividad in PU_i:
          act+=1
          tiempo = math.ceil(random.triangular(int(actividad[2]), int(actividad[4]), int(actividad[3])))
          matriz.append({
                  'Actividad': act,
                  'Paciente': paciente_id,
                  'Prioridad': prioridad,
                  'TR': actividad[0],
                  'Recursos_Necesarios': actividad[1],
                  'Tiempo': tiempo
              })
          array_actividades.append(act)
      orden_actividades_por_paciente[paciente_id] = array_actividades # esto solo lo queremos para ACO_Actividades

    # Crear DataFrame de pacientes
    df_pacientes = pd.DataFrame(pacientes)
    # 1. Ordenar el DataFrame por la columna 'Visto', de tal manera que salgan los ya atendidos primero
    df_pacientes = df_pacientes.sort_values(by='visto', ascending=False)
    # 2.Ordenamos por prioridad
    df_pacientes = df_pacientes.sort_values(by='Prioridad', ascending=True)

    # Crear DataFrame de recursos ocupados
    df_recursos_ocupados = pd.DataFrame(recursos_ocupados)

    # Crear DataFrame de todos los recursos con t_disponible = 0 para aquellos que no estén en df_recursos_ocupados
    df_recursos_totales = pd.DataFrame([{"recurso": recurso, "t_disponible": 0} for recurso in recursos])

    #Combinar DataFrames para obtener el DataFrame final de recursos
    if len(df_recursos_ocupados) > 0:
      df_ocupados = df_recursos_ocupados.drop('TR', axis=1)
      df_recursos_final = pd.concat([df_recursos_totales, df_ocupados], ignore_index=True).groupby("recurso").max().reset_index()

    else:
      df_recursos_final = df_recursos_totales

    # DF datos
    df_datos = pd.DataFrame(matriz)


    return df_pacientes, df_recursos_final, recursos, df_datos, df_recursos_ocupados, orden_actividades_por_paciente

