# -*- coding: utf-8 -*-
"""acciones.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_G7kTMTZuHmCMdp70MW84PcKSlNa_L8W
"""

import pandas as pd
import plotly.express as px
import numpy as np
from datetime import datetime, timedelta
import random
import copy
from operator import itemgetter
import math

def asigna_recurso(tipos_recurso, recursos_disponibles, capacidad_recursos, recurso_actividad, actividad ,tiempo_paciente, tiempo_actividad, paciente, cantidad_recurso_actividad, tiempos_finalizacion_recurso, tiempos_finalizacion_paciente, consultas_asignadas,tiempos_finalizacion_actividad,tiempo_inicio_actividad, recurso_asignado):
  asignado=0
  # Me quedo con la copia para los for (da error por cambiar el array)
  recursos = copy.copy(recursos_disponibles) # [CON1, ENF1,...]
  recursos_tipo_disponibles = {}
  recursos_tipo_no_disponibles = {}
  recursos_asignados = []
  asigna_consulta = 0

  # Me quedo siempre con aquellos recursos que terminan antes (tantos como necesite la actividad)
  ## Luego me quedo con el tiempo max entre todos

  # Cuando la actividad es de consulta, siempre se va a necesitar 1 recurso
  if recurso_actividad in ['CON','ACON']:
    if consultas_asignadas[paciente] == 0: # Si aun no se le ha asignado una consulta a ese paciente
     for recurso in recursos:
        if recurso.startswith(recurso_actividad):
          tiempo = tiempos_finalizacion_recurso.get(recurso,0)
          recursos_tipo_disponibles[recurso] = tiempo # guardamos el recurso en un diccionario con su tiempo de disponibilidad para comparar

     asigna_consulta = 1

    else:
      recurso = consultas_asignadas[paciente]
      tiempo = tiempos_finalizacion_recurso.get(recurso,0)
      recursos_tipo_disponibles[recurso] = tiempo


  else:
    for recurso in recursos:

      if recurso.startswith(recurso_actividad):

          # Mirar si se trata de un recurso cuya capacidad está limitada o no
          ## Si tiene capacidad infinita, se mete cuando el paciente lo requiere (deja de buscar)
          if capacidad_recursos[recurso_actividad] > 1:
            recursos_tipo_disponibles[recurso] = 0 # ponemos 0 para que sea siempre menor que tiempo_paciente
            asignado +=1
            break

          else:
            # Si capacidad no es infinita
            # Me guardo el recurso con su tiempo
            tiempo = tiempos_finalizacion_recurso.get(recurso,0)
            recursos_tipo_disponibles[recurso] = tiempo


  # De los recursos tipo que hay, necesito los que terminan antes ¿SIEMPRE?
  tiempo_inicio = 0
  for i in range(cantidad_recurso_actividad):
     # Ver cuando se libera ANTES alguno de los recursos
      clave_minima = min(recursos_tipo_disponibles, key=lambda k: recursos_tipo_disponibles[k])

      # Guardamos el tiempo del recurso para compararlo con proximos recursos si fuese necesario
      tiempo_inicio_ant = tiempo_inicio
      # La actividad empezará cuando paciente y recurso estén disponibles (tiempo mayor entre los dos)
      tiempo_inicio = max(tiempos_finalizacion_recurso.get(clave_minima,0), tiempo_paciente, tiempo_inicio_ant)

      # Lo guardamos en el array de recursos que sí vamos a asignar
      recursos_asignados.append(clave_minima)
      # Lo eliminamos para que ya no sea el valor mas pequeño del diccionario
      del recursos_tipo_disponibles[clave_minima]

  # Terminado el bucle for tiempo_inicio = tiempo mínimo para empezar la actividad y que tanto paciente y recurso(s) estén disponibles
  # Guardamos el tiempo de inicio de la actividad y de finalización para posteriormente el GANTT
  tiempo_inicio_actividad[actividad] = tiempo_inicio
  tiempos_finalizacion_actividad[actividad] = tiempo_inicio + tiempo_actividad

  # Guardamos el tiempo en el que los recursos y paciente se liberarán tras esta actividad
  for clave in recursos_asignados:
    tiempos_finalizacion_recurso[clave]= (tiempo_inicio + tiempo_actividad)

    if asigna_consulta == 1: # Que ese paciente aun no tiene consulta asignada
      consultas_asignadas[paciente] = clave

  tiempos_finalizacion_paciente[paciente] = tiempo_inicio + tiempo_actividad

  # Guardamos el recurso que se ha asignado a la actividad para el GANTT
  recurso_asignado[actividad] = [clave for clave in recursos_asignados]

def calcula_saturacion(df_datos, df_recursos_ocupados, nivel,tipos_recurso):
  ocupacion_recursos = {}
  saturacion = {}
  LOSmedio = ((3.15+3.14+2.86+1.49+1.31)*60)/5
  flag = 0
  filas = []
  # Iterar sobre las filas del DataFrame y calcular la ocupación acumulada de cada recurso
  for index, row in df_datos.iterrows():
      recurso = row['TR']
      tiempo_actividad = row['Tiempo']


      # Si el recurso ya está en el diccionario, sumar el tiempo de esta actividad
      if recurso in ocupacion_recursos:
          ocupacion_recursos[recurso] += tiempo_actividad
      # Si el recurso no está en el diccionario, agregarlo con el tiempo de esta actividad
      else:
          ocupacion_recursos[recurso] = tiempo_actividad

  for index, row in df_recursos_ocupados.iterrows():
    recurso = row['TR']
    t_ocupado = row['t_disponible']
    if recurso in ocupacion_recursos:
        ocupacion_recursos[recurso] += t_ocupado
    else:
        ocupacion_recursos[recurso] = t_ocupado

  # Mostrar la ocupación acumulada de cada recurso
  for recurso, ocupacion in ocupacion_recursos.items():
      n = tipos_recurso[recurso]
      sat = LOSmedio * n
      saturacion[recurso] = (ocupacion/sat)*100
      #print(f"Recurso {recurso}: Ocupación acumulada = {ocupacion} minutos, saturación = {saturacion[recurso]}")
      if saturacion[recurso] > nivel:
          flag = 1

      filas.append([recurso, ocupacion, saturacion[recurso]])

  df_saturacion = pd.DataFrame(filas, columns=['Recurso', 'Ocupación (min)', 'Saturación %'])

  return flag, df_saturacion

def FO_solucion(df_pacientes, tiempo_final_paciente):
  max_value = 0
  tepcof_FO =0
  clave_maxima, maximo_valor = max(tiempo_final_paciente.items(), key=lambda x: x[1])
  for index, row in df_pacientes.iterrows():
    t_llegada = row['t_llegada']
    tepcof = row['TEPCOF_real']
    epcof = row['TEPCOF']
    prioridad = row['Prioridad']
    if t_llegada is not None and tepcof is not None and epcof is not None:
      if t_llegada >= max_value :
        max_value = t_llegada
      if tepcof > epcof:
        tepcof_FO += tepcof * (6-prioridad)

  FO = maximo_valor + max_value + tepcof_FO
  return FO

def calcula_TEPCOF(df_pacientes, df_datos_unido):
  # Itera sobre las filas del DataFrame
  for index1, row1 in df_pacientes.iterrows():
        tiempo_primera_actividad = 1000
        if row1['visto'] == 0:
          a = row1['Paciente']
          b = row1['t_llegada']
          # Guardamos el tiempo de su primera actividad (el tiempo de inicio mas pequeño)
          for index2, row2 in df_datos_unido.iterrows():
            if row2['Paciente'] == a:
              t_inicio = df_datos_unido.loc[index2,'Tiempo_inicio']
              if t_inicio < tiempo_primera_actividad:
                tiempo_primera_actividad = t_inicio

          calculo = tiempo_primera_actividad + b
        else:
          calculo = None


        # Añadimos el dato en una nueva columna, en el indice correspondiente del primer DataFrame

        df_pacientes.at[index1, 'TEPCOF_real'] = calculo

  return df_pacientes

# -------------------------------------- PARA ACO1, ACO2 Y ACO3 ------------------------------------------
# DECODING
# --------------------------------------------------------------------------------------------------------
def ejecuta_decoding(rep_solucion, df_pacientes, df_recursos_final, df_datos, array_pacientes,TR, R, CR):
  # Diccionarios (clave: valor) para mayor legibilidad de los resultados
  tiempo_inicio_actividad={}
  tiempos_finalizacion_actividad={}
  consultas_asignadas = {}
  recurso_asignado={}

  # Inicializamos las consultas asignadas a cada paciente
  for i in array_pacientes:
     consultas_asignadas[i] = 0 # Posteriormente tendrá la siguiente pinta: paciente 1: CON1, paciente 2: CON2 ...
  

    # Seleccionar las columnas de interés
  columna_clave = 'Paciente'
  columna_valor = 't_disponible'

    # Crear el diccionario
  tiempo_final_paciente = df_pacientes.set_index(columna_clave)[columna_valor].to_dict()

    # Seleccionar las columnas de interés
  columna_clave2 = 'recurso'
  columna_valor2 = 't_disponible'

    # Crear el diccionario
  tiempo_final_recurso = df_recursos_final.set_index(columna_clave2)[columna_valor2].to_dict()

  ## Bucle que organiza actividades en orden de la solucion
  for actividad in rep_solucion:
        # ¿Qué tipo de recurso necesita la actividad?
        indice = df_datos.loc[df_datos['Actividad'] == actividad].index.item()
        paciente, tipo, cantidad_recurso_actividad, tiempo_actividad = df_datos.loc[indice,['Paciente','TR','Recursos_Necesarios','Tiempo']]
        tiempo_p = tiempo_final_paciente.get(paciente,0)

        asigna_recurso(TR, R, CR, tipo, actividad ,tiempo_p, tiempo_actividad, paciente, cantidad_recurso_actividad, tiempo_final_recurso, tiempo_final_paciente, consultas_asignadas,tiempos_finalizacion_actividad,tiempo_inicio_actividad, recurso_asignado)

  data_list = []
  for key, value in tiempos_finalizacion_actividad.items():
          data_list.append({'Actividad': key, 'Recurso_asignado': recurso_asignado[key],'Tiempo_inicio':tiempo_inicio_actividad[key], 'Tiempo_FIN': value})
  Data_pacientes = pd.DataFrame(data_list)
  df_datos_unido = pd.merge(df_datos, Data_pacientes, on='Actividad', how='inner')

  ### Calcula TEPCOF:
  df_pacientes = calcula_TEPCOF(df_pacientes, df_datos_unido)

  ### Calcula FO:
  FO=FO_solucion(df_pacientes, tiempo_final_paciente)

  return FO, df_datos_unido, df_pacientes

# ------------------------------------------------- PARA ACO4 --------------------------------------------
# DECODING
# --------------------------------------------------------------------------------------------------------
def ejecuta_decoding_pacientes(df_datos ,df_pacientes, solucion, df_recursos_final, TR, R, CR):
  # Diccionarios (clave: valor) para mayor legibilidad de los resultados
  tiempo_inicio_actividad={}
  tiempos_finalizacion_actividad={}
  consultas_asignadas = {}
  recurso_asignado={}

  # Inicializamos las consultas asignadas a cada paciente
  for i in solucion:
    consultas_asignadas[i] = 0 # paciente 1: CON1, paciente 2: CON2 ...

  # Organizamos las actividades en función del orden establecido por la hormiga
  matriz_actividades = df_datos.groupby('Paciente')['Actividad'].apply(list).reindex(solucion).tolist() # solucion = [2, 1, 3, 4]
  # Obtener la longitud máxima de las sublistas en Pu_ordenado
  longitud_maxima = max(map(len, matriz_actividades))
  # Rellenar con ceros las sublistas que no llegan al máximo para poder transponerla sin perder actividades
  Pu_transpuesto = [sublista + ['0'] * (longitud_maxima - len(sublista)) for sublista in matriz_actividades]

  # Transponer la lista resultante
  Pu_transpuesto = list(map(list, zip(*Pu_transpuesto)))
  # Obtenemos la matriz de Pu sin los ceros
  rep_solucion = []
  for i in Pu_transpuesto:
    for j in i:
      if j!='0':
        rep_solucion.append(j)

    # Seleccionar las columnas de interés
  columna_clave = 'Paciente'
  columna_valor = 't_disponible'

    # Crear el diccionario
  tiempo_final_paciente = df_pacientes.set_index(columna_clave)[columna_valor].to_dict()

    # Seleccionar las columnas de interés
  columna_clave2 = 'recurso'
  columna_valor2 = 't_disponible'

    # Crear el diccionario
  tiempo_final_recurso = df_recursos_final.set_index(columna_clave2)[columna_valor2].to_dict()

  ## Bucle que organiza actividades en orden de la solucion
  for actividad in rep_solucion:
        # ¿Qué tipo de recurso necesita la actividad?
        indice = df_datos.loc[df_datos['Actividad'] == actividad].index.item()
        paciente, tipo, cantidad_recurso_actividad, tiempo_actividad = df_datos.loc[indice,['Paciente','TR','Recursos_Necesarios','Tiempo']]
        tiempo_p = tiempo_final_paciente.get(paciente,0)

        asigna_recurso(TR, R, CR, tipo, actividad ,tiempo_p, tiempo_actividad, paciente, cantidad_recurso_actividad, tiempo_final_recurso, tiempo_final_paciente, consultas_asignadas,tiempos_finalizacion_actividad,tiempo_inicio_actividad, recurso_asignado)


  #####################################################################################
  ### Calcula TEPCOF:

  data_list = []
  for key, value in tiempos_finalizacion_actividad.items():
          data_list.append({'Actividad': key, 'Recurso_asignado': recurso_asignado[key],'Tiempo_inicio':tiempo_inicio_actividad[key], 'Tiempo_FIN': value})

      # Crear un DataFrame a partir de la lista de diccionarios
  Data_pacientes = pd.DataFrame(data_list)
  df_datos_unido = pd.merge(df_datos, Data_pacientes, on='Actividad', how='inner')

      # Itera sobre las filas del DataFrame
  for index1, row1 in df_pacientes.iterrows():
        tiempo_primera_actividad = 1000
        if row1['visto'] == 0:
          a = row1['Paciente']
          b = row1['t_llegada']
          # Guardamos el tiempo de su primera actividad (el tiempo de inicio mas pequeño)
          for index2, row2 in df_datos_unido.iterrows():
            if row2['Paciente'] == a:
              t_inicio = df_datos_unido.loc[index2,'Tiempo_inicio']
              if t_inicio < tiempo_primera_actividad:
                tiempo_primera_actividad = t_inicio

          calculo = tiempo_primera_actividad + b
        else:
          calculo = None


        # Añadimos el dato en una nueva columna, en el indice correspondiente del primer DataFrame

        df_pacientes.at[index1, 'TEPCOF_real'] = calculo

  #### Calcula FO
  FO=FO_solucion(df_pacientes, tiempo_final_paciente)
  #representa_GANTT(df_datos_unido)
  return FO, df_pacientes, df_datos_unido

def BL_ejecuta_decoding(df_datos ,df_pacientes, solucion, df_recursos_final, TR, R, CR):
  # Diccionarios (clave: valor) para mayor legibilidad de los resultados
  tiempo_inicio_actividad={}
  tiempos_finalizacion_actividad={}
  consultas_asignadas = {}
  recurso_asignado={}

  # Inicializamos las consultas asignadas a cada paciente
  for i in solucion:
     consultas_asignadas[i] = 0 # paciente 1: CON1, paciente 2: CON2 ...

  # Organizamos las actividades en función del orden establecido por la hormiga
  matriz_actividades = df_datos.groupby('Paciente')['Actividad'].apply(list).reindex(solucion).tolist() # solucion = [2, 1, 3, 4]

  # Obtener la longitud máxima de las sublistas en Pu_ordenado
  longitud_maxima = max(map(len, matriz_actividades))

  # Rellenar con ceros las sublistas que no llegan al máximo para poder transponerla sin perder actividades
  Pu_transpuesto = [sublista + ['0'] * (longitud_maxima - len(sublista)) for sublista in matriz_actividades]

  # Transponer la lista resultante
  Pu_transpuesto = list(map(list, zip(*Pu_transpuesto)))
  # Obtenemos la matriz de Pu sin los ceros
  rep_solucion = []
  for i in Pu_transpuesto:
    for j in i:
      if j!='0':
        rep_solucion.append(j)

    # Seleccionar las columnas de interés
  columna_clave = 'Paciente'
  columna_valor = 't_disponible'

    # Crear el diccionario
  tiempo_final_paciente = df_pacientes.set_index(columna_clave)[columna_valor].to_dict()

    # Seleccionar las columnas de interés
  columna_clave2 = 'recurso'
  columna_valor2 = 't_disponible'

    # Crear el diccionario
  tiempo_final_recurso = df_recursos_final.set_index(columna_clave2)[columna_valor2].to_dict()

  ## Bucle que organiza actividades en orden de la solucion
  for actividad in rep_solucion:
        # ¿Qué tipo de recurso necesita la actividad?
        indice = df_datos.loc[df_datos['Actividad'] == actividad].index.item()
        paciente, tipo, cantidad_recurso_actividad, tiempo_actividad = df_datos.loc[indice,['Paciente','TR','Recursos_Necesarios','Tiempo']]
        tiempo_p = tiempo_final_paciente.get(paciente,0)

        asigna_recurso(TR, R, CR, tipo, actividad ,tiempo_p, tiempo_actividad, paciente, cantidad_recurso_actividad, tiempo_final_recurso, tiempo_final_paciente, consultas_asignadas,tiempos_finalizacion_actividad,tiempo_inicio_actividad, recurso_asignado)


  #####################################################################################
  ### Calcula TEPCOF:

  data_list = []
  for key, value in tiempos_finalizacion_actividad.items():
          data_list.append({'Actividad': key, 'Recurso_asignado': recurso_asignado[key],'Tiempo_inicio':tiempo_inicio_actividad[key], 'Tiempo_FIN': value})

      # Crear un DataFrame a partir de la lista de diccionarios
  Data_pacientes = pd.DataFrame(data_list)
  df_datos_unido = pd.merge(df_datos, Data_pacientes, on='Actividad', how='inner')

      # Itera sobre las filas del DataFrame
  for index1, row1 in df_pacientes.iterrows():
        tiempo_primera_actividad = 1000
        if row1['visto'] == 0:
          a = row1['Paciente']
          b = row1['t_llegada']
          # Guardamos el tiempo de su primera actividad (el tiempo de inicio mas pequeño)
          for index2, row2 in df_datos_unido.iterrows():
            if row2['Paciente'] == a:
              t_inicio = df_datos_unido.loc[index2,'Tiempo_inicio']
              if t_inicio < tiempo_primera_actividad:
                tiempo_primera_actividad = t_inicio

          calculo = tiempo_primera_actividad + b
        else:
          calculo = None


        # Añadimos el dato en una nueva columna, en el indice correspondiente del primer DataFrame

        df_pacientes.at[index1, 'TEPCOF_real'] = calculo

  #### Calcula FO
  FO=FO_solucion(df_pacientes, tiempo_final_paciente)

  return FO