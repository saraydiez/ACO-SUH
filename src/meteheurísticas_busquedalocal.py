# -*- coding: utf-8 -*-
"""meteheurísticas_busquedalocal.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1pVW0bzrqyBv1Nh2t9GBQNv8Jx4w0QjRB
"""

import pandas as pd
import plotly.express as px
import pandas as pd
import numpy as np
from datetime import datetime, timedelta
import random
import copy
from operator import itemgetter
import math
import time
import matplotlib.pyplot as plt
from src.acciones import ejecuta_decoding, asigna_recurso, ejecuta_decoding_pacientes, BL_ejecuta_decoding

# ------------------------------
# BLOQUE 1: Búsqueda local
# ------------------------------

def select_two_patients(solution):
  indices = np.random.choice(len(solution), 2, replace=False)
  return [solution[i] for i in indices]

def busqueda_local(solucion_inicial, df_datos, df_pacientes, df_recursos_final,TR, R, CR):
   # Copia de la solución inicial para no modificar el original
    current_solution = solucion_inicial[:]

    # Seleccionar dos pacientes aleatorios
    pacientes_sacados = select_two_patients(current_solution)

    #print('Sacados:', pacientes_sacados)

    # SACAR PACIENTES DE LOS DF
    df_pacientes_nuevo = df_pacientes

    # Mantener los pacientes que no han sido sacados
    pacientes_mantenidos = [p for p in current_solution if p not in pacientes_sacados]

    # Filtrar el DataFrame original para mantener solo las filas de pacientes no sacados
    df_datos_mantenidos = df_datos[~df_datos['Paciente'].isin(pacientes_sacados)]
    df_pacientes_mantenidos = df_pacientes[~df_pacientes_nuevo['Paciente'].isin(pacientes_sacados)]

    # Obtener las filas correspondientes a los pacientes sacados
    df_datos_sacados = df_datos[df_datos['Paciente'].isin(pacientes_sacados)]
    df_pacientes_sacados = df_pacientes[df_pacientes['Paciente'].isin(pacientes_sacados)]


    best_solution = None

    # Probar cada paciente sacado en todas las posiciones posibles del array restante
    for p in pacientes_sacados:

        best_score = float('inf') # Dentro del bucle ya que la segunda FO siempre será mayor que la primera alañadir pacientes

        # Seleccionamos las filas del paciente que estudiamos
        df_datos_paciente = df_datos_sacados[df_datos_sacados['Paciente'] == p]
        df_pacientes_paciente = df_pacientes_sacados[df_pacientes_sacados['Paciente'] == p]

        # Las añadimos en el dataframe (da igual orden, luego se ordena según la rep_solución)
        df_datos_mantenidos = pd.concat([df_datos_paciente, df_datos_mantenidos], ignore_index=True)
        df_pacientes_mantenidos = pd.concat([df_pacientes_paciente, df_pacientes_mantenidos], ignore_index=True)

        for i in range(len(pacientes_mantenidos) + 1):
            # Insertar el paciente en la posición i
            new_solution = pacientes_mantenidos[:i] + [p] + pacientes_mantenidos[i:]

            #print(new_solution)
            # Evaluar la nueva solución
            FO_busqueda = BL_ejecuta_decoding(df_datos_mantenidos ,df_pacientes_mantenidos, new_solution, df_recursos_final,TR, R, CR)

            # Si la nueva solución es mejor, actualizar la mejor solución
            if FO_busqueda < best_score:
                best_solution = new_solution
                best_score = FO_busqueda

        # Actualizar pacientes mantenidos para la siguiente iteración
        pacientes_mantenidos = best_solution[:]

    return best_solution, best_score

# ------------------------------
# BLOQUE 2: Metaheurística colonia de hormigas POR ACTIVIDADES
# ------------------------------

# Funciones auxiliares

# Utilizar la solución inicial para ajustar las feromonas
def ajustar_feromonas_iniciales(feromonas, solucion_inicial, calidad_inicial):
    for i in range(len(solucion_inicial) - 1):
        feromonas[solucion_inicial[i]-1][solucion_inicial[i+1]-1] += calidad_inicial  # Ajustar según la calidad de tu solución inicial
    return feromonas

# Función para generar la matriz de costos, teniendo en cuenta las restricciones
# actividades : Actividad	| Paciente	| Prioridad	| TR	| Recursos_Necesarios	| Tiempo
def generar_matriz_costos(actividades,orden_actividades_por_paciente):
    # Aquí debes implementar la lógica para generar los costos entre actividades,
    # respetando las restricciones de precedencia.
    num_actividades = len(actividades)
    matriz_costos = np.full((num_actividades, num_actividades), np.inf)  # Inicializa con infinito

    # Asignar costos en base a tiempo de ocupación y prioridad del paciente
    for i in range(num_actividades):
        for j in range(num_actividades):
            if i != j:  # Asegurarse de que no se esté calculando el costo de una actividad a sí misma
                # Restricciones de secuencia: Solo se consideran transiciones válidas
                if es_transicion_valida(actividades[i][:2], actividades[j][:2], orden_actividades_por_paciente):
                    # El costo podría ser inversamente proporcional a la prioridad del paciente
                    # y directamente proporcional al tiempo de la actividad
                    tiempo = actividades[j][5]  # Tiempo de la actividad destino
                    prioridad = actividades[j][2]  # Prioridad del paciente de la actividad destino
                    matriz_costos[i][j] = calcular_costo(tiempo, prioridad)

    return matriz_costos

def es_transicion_valida(actividad_origen, actividad_destino, orden_actividades_por_paciente):
    paciente_origen = actividad_origen[1]
    paciente_destino = actividad_destino[1]
    actividad_origen_id = actividad_origen[0]
    actividad_destino_id = actividad_destino[0]

    # Validación intra-paciente
    if paciente_origen == paciente_destino:
        indice_origen = orden_actividades_por_paciente[paciente_origen].index(actividad_origen_id)
        indice_destino = orden_actividades_por_paciente[paciente_destino].index(actividad_destino_id)
        return indice_destino == indice_origen + 1 # Devuelve true solo si es justo la actividad que precede a la de origen

    # Validación inter-paciente
    else:
      return True

# Calcular coste de ir a una actividad
def calcular_costo(tiempo, prioridad):
    # Asume que prioridades más altas tienen valores más bajos (1 es la máxima prioridad)
    # y que deseas minimizar tanto el tiempo de espera como atender primero a pacientes prioritarios.

    base_cost = 10  # Costo base para cualquier transición
    costo = base_cost + tiempo - (6-prioridad)
    return costo


def seleccionar_proxima_actividad(alpha, beta, q0, actividades_validas, actividades, feromonas, matriz_costos, orden_actividades_por_paciente, actividades_seleccionadas_por_hormiga):

    if not actividades_validas:
        return None, actividades_validas

    actividad_actual = actividades_seleccionadas_por_hormiga[-1]
    transiciones_validas = []

    for actividad_destino in actividades_validas:
        # Verificar que todas las actividades previas del paciente asociado a esta actividad se hayan completado
        for a in actividades:
          if actividad_destino == a[0]:
            paciente_destino = a[1] # queremos saber el paciente al cual pertenece esa actividad para poder comprobar que se cumple el orden de actividades
            break

        actividades_previas = orden_actividades_por_paciente[paciente_destino][:orden_actividades_por_paciente[paciente_destino].index(actividad_destino)]

        if all(actividad_previa in actividades_seleccionadas_por_hormiga for actividad_previa in actividades_previas):
          transiciones_validas.append(actividad_destino)

    if not transiciones_validas:  # Si no hay transiciones válidas
        return None, actividades_validas

    # Decision de explotación vs exploración
    if random.random() < q0:
        # Explotación: elegir el mejor basado en feromonas y costo (heurística)
        mejor_costo = 0
        seleccionado = None

        for actividad_destino in transiciones_validas:
            tau = feromonas[int(actividad_actual)-1][int(actividad_destino)-1]  # Cantidad de feromona
            costo= matriz_costos[int(actividad_actual)-1][int(actividad_destino)-1] # Valor costo
            eta = 1 / costo if costo != float('inf') else 0  # Inversa del costo como heurística

            # Utilizamos un producto de feromonas y heurística, buscando el máximo
            valor = (tau ** alpha) * (eta ** beta)
            if valor > mejor_costo:
                mejor_costo = valor
                seleccionado = actividad_destino

        actividades_validas.remove(seleccionado)
        return seleccionado, actividades_validas
    else:
        # Exploración: elegir basado en una distribución de probabilidades proporcional a feromonas y heurística
        probabilidades = []
        for actividad_destino in transiciones_validas:
            tau = feromonas[int(actividad_actual)-1][int(actividad_destino)-1]  # Cantidad de feromona
            costo= matriz_costos[int(actividad_actual)-1][int(actividad_destino)-1] # Valor costo
            eta = 1 / costo if costo != float('inf') else 0

            probabilidades.append((tau ** alpha) * (eta ** beta))

        # Normalizar las probabilidades
        suma_probabilidades = sum(probabilidades)
        if suma_probabilidades == 0:
            return None, actividades_validas  # En caso de que todas las probabilidades sean 0

        probabilidades_normalizadas = [prob / suma_probabilidades for prob in probabilidades]
        seleccionado = np.random.choice(transiciones_validas, p=probabilidades_normalizadas)
        actividades_validas.remove(seleccionado)
        return seleccionado, actividades_validas

def generar_solucion_hormiga(best_sol_i, feromonas, matriz_costos,orden_actividades_por_paciente, actividades, actividad_inicial,alpha, beta, q0):

  # Elegir una actividad de inicio (puede ser parte de la solución inicial dada)
  actividades_seleccionadas_por_hormiga = []
  actividades_seleccionadas_por_hormiga.append(actividad_inicial)
  actividades_validas = copy.copy(best_sol_i)
  actividades_validas.remove(actividad_inicial)

  # Mientras que la solución no esté completa
  while len(actividades_seleccionadas_por_hormiga) < len(best_sol_i):
            prox_actividad, actividades_validas = seleccionar_proxima_actividad(alpha, beta, q0,actividades_validas, actividades, feromonas, matriz_costos, orden_actividades_por_paciente, actividades_seleccionadas_por_hormiga)
            actividades_seleccionadas_por_hormiga.append(prox_actividad)

  return actividades_seleccionadas_por_hormiga
# Actualización de feromonas
def actualizar_feromonas(matriz_feromonas, soluciones_hormigas, calidad_soluciones, evaporacion):
    """
    Actualiza la matriz de feromonas basada en las soluciones encontradas por las hormigas y su calidad.

    Parámetros:
    - matriz_feromonas: Matriz de feromonas actual.
    - soluciones_hormigas: Lista de soluciones encontradas por las hormigas.
    - calidad_soluciones: Lista con un valor representativo de la calidad de cada solución.
    - evaporacion: Tasa de evaporación de la feromona.
    """
    # Evaporación de feromonas
    matriz_feromonas *= (1 - evaporacion)

    # Refuerzo de feromonas basado en la calidad de las soluciones
    #for solucion, calidad in zip(soluciones_hormigas, calidad_soluciones):
    for i in range(len(soluciones_hormigas)-1):
            # Aumentar las feromonas basado en la calidad de la solución
            matriz_feromonas[soluciones_hormigas[i]-1][soluciones_hormigas[i+1]-1] += calidad_soluciones

    return matriz_feromonas

def calcular_calidad_solucion(FO_decoding):
    """
    Calcula la calidad de una solución basada en el inverso del tiempo total.
    Valor representativo de la calidad de la solución. Soluciones con menor tiempo total tendrán una calidad mayor.
    """
    if FO_decoding > 0:
        return 100 / FO_decoding
    else:
        return float('inf')  # En caso de que tiempo_total sea 0, lo cual es improbable en escenarios reales.

# ------------------------------
# ACO1 + BL
# ------------------------------

def algoritmo_aco1_bl(tiempo_computacion,array_pacientes, num_hormigas, parametros ,Q_0, FO_inicial, solucion_inicial, actividades, orden_actividades_por_paciente, df_pacientes, df_recursos_final, df_datos, TR, R, CR):
    # Inicializar parametros
    num_actividades = len(actividades)  # Ajustar según tu caso

    alpha = parametros[0] # Influencia de la feromona
    beta = parametros [1] # Influencia de la información heurística
    evaporacion = parametros[2] # Tasa de evaporación de la feromona
    q0 = Q_0
    feromonas = np.ones((num_actividades, num_actividades))
    best_hormiga = []
    best_hormiga_calidad = []
    best_hormiga_FO = []
    best_sol_i = solucion_inicial # ACO 2 Y 3
    # Crear un DataFrame vacío
    df = pd.DataFrame(columns=['Iteracion','FO','Algoritmo'])
    # Inicializar las feromonas según solución inicial
    coste_inicial= calcular_calidad_solucion(FO_inicial)
    feromonas = ajustar_feromonas_iniciales(feromonas, solucion_inicial, coste_inicial)
    matriz_costo = generar_matriz_costos(actividades,orden_actividades_por_paciente)
    best_hormiga.append(solucion_inicial)
    best_hormiga_calidad.append(coste_inicial)

    tiempo_inicial = time.time()
    best_value = float('inf')
    counter = 0
    iteracion = 0
    bl = 0


    while (time.time() - tiempo_inicial) < tiempo_computacion:
        iteracion += 1

        soluciones_hormigas = []
        calidad_soluciones = []
        FO_soluciones = []
        tiempo_cero = time.time()
        # Generar soluciones para cada hormiga
        for hormiga in range(num_hormigas):
            if bl == 0:
              actividad_inicial = solucion_inicial[0] # ACO 1
              solucion_hormiga = generar_solucion_hormiga(best_sol_i, feromonas, matriz_costo, orden_actividades_por_paciente, actividades, actividad_inicial,alpha, beta, q0)
            else:
              bl = 0
              # Organizamos las actividades en función del orden establecido por la hormiga
              matriz_actividades = df_datos.groupby('Paciente')['Actividad'].apply(list).reindex(best_sol_bl).tolist() # solucion = [2, 1, 3, 4]
              # Obtener la longitud máxima de las sublistas en Pu_ordenado
              longitud_maxima = max(map(len, matriz_actividades))
              # Rellenar con ceros las sublistas que no llegan al máximo para poder transponerla sin perder actividades
              Pu_transpuesto = [sublista + ['0'] * (longitud_maxima - len(sublista)) for sublista in matriz_actividades]

              # Transponer la lista resultante
              Pu_transpuesto = list(map(list, zip(*Pu_transpuesto)))
              # Obtenemos la matriz de Pu sin los ceros
              rep_solucion = []
              for i in Pu_transpuesto:
                for j in i:
                  if j!='0':
                    rep_solucion.append(j)

              solucion_hormiga = rep_solucion

            FO_hormiga, df_datos_unido, df_pacientes = ejecuta_decoding(solucion_hormiga, df_pacientes, df_recursos_final, df_datos,array_pacientes, TR, R, CR)  # Implementar evaluación de la solución. Calcular su FO
            soluciones_hormigas.append(solucion_hormiga)
            calidad_soluciones.append(calcular_calidad_solucion(FO_hormiga))  # Implementar evaluación de la solución
            FO_soluciones.append(FO_hormiga)
            #print(calcular_calidad_solucion(FO_hormiga))

        # Actualizar feromonas
        tiempo_fin = time.time()
        #indice_best_hormiga = calidad_soluciones.index(max(calidad_soluciones))
        indice_best_hormiga = FO_soluciones.index(min(FO_soluciones))
        best_hormiga.append(soluciones_hormigas[indice_best_hormiga]) # Guardamos la mejor solucion de esta vuelta
        best_hormiga_calidad.append(calidad_soluciones[indice_best_hormiga])
        best_hormiga_FO.append(FO_soluciones[indice_best_hormiga])
        feromonas = actualizar_feromonas(feromonas, soluciones_hormigas[indice_best_hormiga], calidad_soluciones[indice_best_hormiga], evaporacion)

        best_sol_i = best_hormiga[best_hormiga_calidad.index(max(best_hormiga_calidad))] # Sirve solo en caso de lanzar ACO_3 (si no solo vale para saber las actividades que hay)
        # Agregar valores al DataFrame usando loc
        df.loc[len(df)] = [iteracion, FO_soluciones[indice_best_hormiga],'ACO1']

        if iteracion >= 3 and len(set(best_hormiga_FO[-3:])) == 1:
          bl = 1
          best_sol_bl , best_FO_bl = busqueda_local(array_pacientes, df_datos, df_pacientes, df_recursos_final,TR, R, CR)

        # Contador de mejores soluciones
        for index, row in df.iterrows():
            current_value = row['FO']
            if current_value < best_value:
                best_value = current_value
                counter += 1


    best_sol = best_hormiga[best_hormiga_FO.index(min(best_hormiga_FO))]
    FO_best = min(best_hormiga_FO)
    return best_sol, df, FO_best, counter, df_datos_unido

# ------------------------------
# ACO2 + BL
# ------------------------------

def algoritmo_aco2_bl(tiempo_computacion,array_pacientes, num_hormigas, parametros ,Q_0, FO_inicial, solucion_inicial, actividades, orden_actividades_por_paciente, df_pacientes, df_recursos_final, df_datos, TR, R, CR):
    # Inicializar parametros
    num_actividades = len(actividades)  # Ajustar según tu caso

    alpha = parametros[0] # Influencia de la feromona
    beta = parametros [1] # Influencia de la información heurística
    evaporacion = parametros[2] # Tasa de evaporación de la feromona
    q0 = Q_0
    feromonas = np.ones((num_actividades, num_actividades))
    best_hormiga = []
    best_hormiga_calidad = []
    best_hormiga_FO = []
    # Crear un DataFrame vacío
    df = pd.DataFrame(columns=['Iteracion','FO','Algoritmo'])
    # Inicializar las feromonas según solución inicial
    coste_inicial= calcular_calidad_solucion(FO_inicial)
    feromonas = ajustar_feromonas_iniciales(feromonas, solucion_inicial, coste_inicial)
    matriz_costo = generar_matriz_costos(actividades,orden_actividades_por_paciente)
    best_hormiga.append(solucion_inicial)
    best_hormiga_calidad.append(coste_inicial)
    best_sol_i = solucion_inicial # ACO 2 Y 3
    tiempo_inicial = time.time()
    best_value = float('inf')
    counter = 0
    iteracion = 0
    bl = 0

    while (time.time() - tiempo_inicial) < tiempo_computacion:
        iteracion += 1

        soluciones_hormigas = []
        calidad_soluciones = []
        FO_soluciones = []
        tiempo_cero = time.time()
        # Generar soluciones para cada hormiga
        for hormiga in range(num_hormigas):
            if bl == 0:
              paciente_inicial = np.random.choice(range(1,len(orden_actividades_por_paciente)))
              actividad_inicial = orden_actividades_por_paciente[paciente_inicial][0] # ACO 2

              solucion_hormiga = generar_solucion_hormiga(best_sol_i, feromonas, matriz_costo, orden_actividades_por_paciente, actividades, actividad_inicial,alpha, beta, q0)

            else:
              bl = 0
              # Organizamos las actividades en función del orden establecido por la hormiga
              matriz_actividades = df_datos.groupby('Paciente')['Actividad'].apply(list).reindex(best_sol_bl).tolist() # solucion = [2, 1, 3, 4]
              # Obtener la longitud máxima de las sublistas en Pu_ordenado
              longitud_maxima = max(map(len, matriz_actividades))
              # Rellenar con ceros las sublistas que no llegan al máximo para poder transponerla sin perder actividades
              Pu_transpuesto = [sublista + ['0'] * (longitud_maxima - len(sublista)) for sublista in matriz_actividades]

              # Transponer la lista resultante
              Pu_transpuesto = list(map(list, zip(*Pu_transpuesto)))
              # Obtenemos la matriz de Pu sin los ceros
              rep_solucion = []
              for i in Pu_transpuesto:
                for j in i:
                  if j!='0':
                    rep_solucion.append(j)

              solucion_hormiga = rep_solucion

            FO_hormiga, df_datos_unido, df_pacientes = ejecuta_decoding(solucion_hormiga, df_pacientes, df_recursos_final, df_datos,array_pacientes, TR, R, CR)  # Implementar evaluación de la solución. Calcular su FO
            soluciones_hormigas.append(solucion_hormiga)
            calidad_soluciones.append(calcular_calidad_solucion(FO_hormiga))  # Implementar evaluación de la solución
            FO_soluciones.append(FO_hormiga)
            #print(calcular_calidad_solucion(FO_hormiga))

        # Actualizar feromonas
        tiempo_fin = time.time()
        #indice_best_hormiga = calidad_soluciones.index(max(calidad_soluciones))
        indice_best_hormiga = FO_soluciones.index(min(FO_soluciones))
        best_hormiga.append(soluciones_hormigas[indice_best_hormiga]) # Guardamos la mejor solucion de esta vuelta
        best_hormiga_calidad.append(calidad_soluciones[indice_best_hormiga])
        best_hormiga_FO.append(FO_soluciones[indice_best_hormiga])
        feromonas = actualizar_feromonas(feromonas, soluciones_hormigas[indice_best_hormiga], calidad_soluciones[indice_best_hormiga], evaporacion)

        best_sol_i = best_hormiga[best_hormiga_calidad.index(max(best_hormiga_calidad))] # Sirve solo en caso de lanzar ACO_3 (si no solo vale para saber las actividades que hay)
        # Agregar valores al DataFrame usando loc
        df.loc[len(df)] = [iteracion, FO_soluciones[indice_best_hormiga],'ACO2']

        if iteracion >= 3 and len(set(best_hormiga_FO[-3:])) == 1:
          bl = 1
          best_sol_bl , best_FO_bl = busqueda_local(array_pacientes, df_datos, df_pacientes, df_recursos_final,TR, R, CR)
          #print('nueva solucion', best_sol_bl)

        # Contador de mejores soluciones
        for index, row in df.iterrows():
            current_value = row['FO']
            if current_value < best_value:
                best_value = current_value
                counter += 1


    best_sol = best_hormiga[best_hormiga_FO.index(min(best_hormiga_FO))]
    FO_best = min(best_hormiga_FO)
    return best_sol, df, FO_best,counter, df_datos_unido

# ------------------------------
# ACO3 + BL
# ------------------------------

def algoritmo_aco3_bl(tiempo_computacion, array_pacientes, num_hormigas, parametros ,Q_0, FO_inicial, solucion_inicial, actividades, orden_actividades_por_paciente, df_pacientes, df_recursos_final, df_datos, TR, R, CR):
    # Inicializar parametros
    num_actividades = len(actividades)  # Ajustar según tu caso

    alpha = parametros[0] # Influencia de la feromona
    beta = parametros [1] # Influencia de la información heurística
    evaporacion = parametros[2] # Tasa de evaporación de la feromona
    q0 = Q_0
    feromonas = np.ones((num_actividades, num_actividades))
    best_hormiga = []
    best_hormiga_calidad = []
    best_hormiga_FO = []
    # Crear un DataFrame vacío
    df = pd.DataFrame(columns=['Iteracion','FO','Algoritmo'])
    # Inicializar las feromonas según solución inicial
    coste_inicial= calcular_calidad_solucion(FO_inicial)
    feromonas = ajustar_feromonas_iniciales(feromonas, solucion_inicial, coste_inicial)
    matriz_costo = generar_matriz_costos(actividades,orden_actividades_por_paciente)
    best_hormiga.append(solucion_inicial)
    best_hormiga_calidad.append(coste_inicial)
    best_sol_i = solucion_inicial # ACO 2 Y 3
    tiempo_inicial = time.time()
    best_value = float('inf')
    counter = 0
    iteracion = 0
    bl=0


    while (time.time() - tiempo_inicial) < tiempo_computacion:
        iteracion += 1

        soluciones_hormigas = []
        calidad_soluciones = []
        FO_soluciones = []
        tiempo_cero = time.time()
        # Generar soluciones para cada hormiga
        for hormiga in range(num_hormigas):
            if bl == 0:
              actividad_inicial = best_sol_i[0] # ACO 3
              solucion_hormiga = generar_solucion_hormiga(best_sol_i, feromonas, matriz_costo, orden_actividades_por_paciente, actividades, actividad_inicial,alpha, beta, q0)

            else:
              bl = 0
              # Organizamos las actividades en función del orden establecido por la hormiga
              matriz_actividades = df_datos.groupby('Paciente')['Actividad'].apply(list).reindex(best_sol_bl).tolist() # solucion = [2, 1, 3, 4]
              # Obtener la longitud máxima de las sublistas en Pu_ordenado
              longitud_maxima = max(map(len, matriz_actividades))
              # Rellenar con ceros las sublistas que no llegan al máximo para poder transponerla sin perder actividades
              Pu_transpuesto = [sublista + ['0'] * (longitud_maxima - len(sublista)) for sublista in matriz_actividades]

              # Transponer la lista resultante
              Pu_transpuesto = list(map(list, zip(*Pu_transpuesto)))
              # Obtenemos la matriz de Pu sin los ceros
              rep_solucion = []
              for i in Pu_transpuesto:
                for j in i:
                  if j!='0':
                    rep_solucion.append(j)

              solucion_hormiga = rep_solucion

            FO_hormiga, df_datos_unido, df_pacientes = ejecuta_decoding(solucion_hormiga, df_pacientes, df_recursos_final, df_datos,array_pacientes, TR, R, CR)  # Implementar evaluación de la solución. Calcular su FO
            soluciones_hormigas.append(solucion_hormiga)
            calidad_soluciones.append(calcular_calidad_solucion(FO_hormiga))  # Implementar evaluación de la solución
            FO_soluciones.append(FO_hormiga)
            #print(calcular_calidad_solucion(FO_hormiga))

        # Actualizar feromonas
        tiempo_fin = time.time()
        #indice_best_hormiga = calidad_soluciones.index(max(calidad_soluciones))
        indice_best_hormiga = FO_soluciones.index(min(FO_soluciones))
        best_hormiga.append(soluciones_hormigas[indice_best_hormiga]) # Guardamos la mejor solucion de esta vuelta
        best_hormiga_calidad.append(calidad_soluciones[indice_best_hormiga])
        best_hormiga_FO.append(FO_soluciones[indice_best_hormiga])
        feromonas = actualizar_feromonas(feromonas, soluciones_hormigas[indice_best_hormiga], calidad_soluciones[indice_best_hormiga], evaporacion)

        best_sol_i = best_hormiga[best_hormiga_calidad.index(max(best_hormiga_calidad))] # Sirve solo en caso de lanzar ACO_3 (si no solo vale para saber las actividades que hay)
        # Agregar valores al DataFrame usando loc
        df.loc[len(df)] = [iteracion, FO_soluciones[indice_best_hormiga],'ACO3']

        if iteracion >= 3 and len(set(best_hormiga_FO[-3:])) == 1:
          bl = 1
          best_sol_bl , best_FO_bl = busqueda_local(array_pacientes, df_datos, df_pacientes, df_recursos_final,TR, R, CR)
          #print('nueva solucion', best_sol_bl)


        # Contador de mejores soluciones
        for index, row in df.iterrows():
            current_value = row['FO']
            if current_value < best_value:
                best_value = current_value
                counter += 1


    best_sol = best_hormiga[best_hormiga_FO.index(min(best_hormiga_FO))]
    FO_best = min(best_hormiga_FO)
    return best_sol, df, FO_best, counter,df_datos_unido

# ------------------------------
# BLOQUE 3: Metaheurística colonia de hormigas POR PACIENTES
# ------------------------------

# FUNCIONES AUXILIARES (diferentes a las ya definidas)

# Función para generar la matriz de costos - EN ESTE CASO NO HAY RESTRICCIONES DE PRECEDENCIA
# actividades : Actividad	| Paciente	| Prioridad	| TR	| Recursos_Necesarios	| Tiempo
def generar_matriz_costos_pacientes(df_pacientes):
    n_pacientes = len(df_pacientes)  # Número de pacientes
    matriz_costos = np.full((n_pacientes, n_pacientes), np.inf)  # Inicializa la matriz de costos

    # Calcula el costo de transición de cada paciente a todos los demás
    for i in range(n_pacientes):
        for j in range(n_pacientes):
            if i != j:  # Asegura que no se calcule el costo de un paciente a sí mismo
                prioridad_j = df_pacientes.at[j,'Prioridad']
                visto_j = df_pacientes.at[j, 'visto']
                # Calcula el costo según la prioridad y si ha sido visto
                costo = (1 / (6 - prioridad_j)) * (1 - 0.2 * visto_j)
                matriz_costos[i][j] = costo

    return matriz_costos


# Selección de el proximo paciente
def seleccionar_proximo_paciente(pacientes_seleccionados_por_hormiga, matriz_feromonas, matriz_costos, alpha, beta, q0):
    ultimo_paciente = pacientes_seleccionados_por_hormiga[-1]
    candidatos = [i for i in range(len(matriz_costos)) if i not in pacientes_seleccionados_por_hormiga]
    probabilidades = []

    if random.random() < q0:  # Explotación: selecciona el mejor candidato con alta probabilidad q0
        mejor_costo = 0
        seleccionado = None
        for candidato in candidatos:
            # Considera la inversa del costo por la cantidad de feromona para encontrar el 'mejor' camino
            tau = matriz_feromonas[ultimo_paciente][candidato]  # Intensidad de la feromona
            costo = matriz_costos[ultimo_paciente][candidato]
            eta = 1 / costo if costo != float('inf') else 0  # Inversa del costo como heurística
            # Utilizamos un producto de feromonas y heurística, buscando el máximo
            valor = (tau ** alpha) * (eta ** beta)

            if valor > mejor_costo:
                mejor_costo = valor
                seleccionado = candidato

    else:  # Exploración: selecciona un candidato basado en una distribución de probabilidad
      for candidato in candidatos:
        tau = matriz_feromonas[ultimo_paciente][candidato]
        eta = 1/matriz_costos[ultimo_paciente][candidato]
        probabilidades.append((tau ** alpha) * (eta ** beta))

      suma_probabilidades = sum(probabilidades)
      probabilidades_normalizadas = [p/suma_probabilidades for p in probabilidades]
      # Selecciona un candidato de manera aleatoria ponderada por las probabilidades normalizadas
      seleccionado = random.choices(candidatos, weights=probabilidades_normalizadas, k=1)[0]

    return seleccionado

# Actualización de feromonas
def actualizar_feromonas_pacientes(matriz_feromonas, solucion, calidad, tasa_evaporacion):

    # Evaporación de feromonas
      # Evaporación de feromonas
    for i in range(len(matriz_feromonas)):
      for j in range(len(matriz_feromonas)):
        matriz_feromonas[i][j] *= (1 - tasa_evaporacion)

    # Refuerzo de feromonas para cada solución encontrada por las hormigas
    #for solucion, calidad in zip(soluciones, calidad_soluciones):
    for i in range(len(solucion)-1):
            # Aumentar las feromonas basado en la calidad de la solución
           matriz_feromonas[solucion[i]-1][solucion[i+1]-1] += calidad

    return matriz_feromonas

# ------------------------------
# ACO4 + BL
# ------------------------------

def algoritmo_aco_bl_pacientes(tiempo_computacion, array_pacientes, FO_inicial,solucion_inicial, num_hormigas, df_pacientes ,df_recursos_final, df_datos, alpha, beta, ro,q0,TR, R, CR):
    semilla = 0
    num_pacientes = len(df_pacientes)

    # Inicialización de la matriz de feromonas
    matriz_feromonas = [[1 for _ in range(num_pacientes)] for _ in range(num_pacientes)]
    # Inicializamos feromonas según la solución inicial
    calidad_inicial = calcular_calidad_solucion(FO_inicial)
    feromonas = ajustar_feromonas_iniciales(matriz_feromonas, solucion_inicial, calidad_inicial)
    matriz_costos = generar_matriz_costos_pacientes(df_pacientes)  # Suponiendo que ya tienes una lista 'pacientes' definida

    mejor_solucion = []
    mejor_solucion_calidad = []
    mejor_solucion_FO = []
    tiempo_inicial = time.time()
    # Crear un DataFrame vacío
    df = pd.DataFrame(columns=['Iteracion','FO', 'Algoritmo'])
    iteracion = 0
    best_value = float('inf')
    counter = 0
    bl = 0

    #for iteracion in range(num_iteraciones): # Poner que pare en tiempo y en iteraciones ( con pacientes llegará a convergir mas rapido )
    while (time.time() - tiempo_inicial) < tiempo_computacion:
        soluciones = []  # Lista para almacenar las soluciones de esta iteración
        calidad_soluciones = []
        FO_soluciones = []
        iteracion += 1
        for n in range(num_hormigas):
            if bl == 0:
              pacientes_seleccionados_por_hormiga = [random.randint(0, num_pacientes-1)]  # Inicia con un paciente aleatorio


              #print('primer paciente:',pacientes_seleccionados_por_hormiga)
              while len(pacientes_seleccionados_por_hormiga) < num_pacientes:
                  proximo_paciente = seleccionar_proximo_paciente(pacientes_seleccionados_por_hormiga, matriz_feromonas, matriz_costos, alpha, beta, q0) #pacientes_seleccionados_por_hormiga, matriz_feromonas, matriz_costos, alpha, beta, q0
                  pacientes_seleccionados_por_hormiga.append(proximo_paciente)

              # Calcula el costo de la solución encontrada (en función de la FO)
              pacientes_seleccionados_por_hormiga = [x + 1 for x in pacientes_seleccionados_por_hormiga]

              ### CONVERTIMOS EN UNA SOLUCIÓN QUE PUEDA EJECUTAR NUESTRO DECODING

              # Organizamos las actividades en función del orden establecido por la hormiga
              matriz_actividades = df_datos.groupby('Paciente')['Actividad'].apply(list).reindex(pacientes_seleccionados_por_hormiga).tolist() # solucion = [2, 1, 3, 4]
              # Obtener la longitud máxima de las sublistas en Pu_ordenado
              longitud_maxima = max(map(len, matriz_actividades))
              # Rellenar con ceros las sublistas que no llegan al máximo para poder transponerla sin perder actividades
              Pu_transpuesto = [sublista + ['0'] * (longitud_maxima - len(sublista)) for sublista in matriz_actividades]

              # Transponer la lista resultante
              Pu_transpuesto = list(map(list, zip(*Pu_transpuesto)))
              # Obtenemos la matriz de Pu sin los ceros
              rep_solucion = []
              for i in Pu_transpuesto:
                for j in i:
                  if j!='0':
                    rep_solucion.append(j)


              FO_hormiga, df_datos_unido, df_pacientes = ejecuta_decoding(rep_solucion, df_pacientes, df_recursos_final, df_datos,array_pacientes,TR, R, CR)  # Implementar evaluación de la solución. Calcular su FO
              soluciones.append(pacientes_seleccionados_por_hormiga)
              calidad_soluciones.append(calcular_calidad_solucion(FO_hormiga))  # Implementar evaluación de la solución
              FO_soluciones.append(FO_hormiga)

            else:
               pacientes_seleccionados_por_hormiga = best_sol_bl
               bl = 0

               ## CONVERTIMOS EN UNA SOLUCIÓN QUE PUEDA EJECUTAR NUESTRO DECODING

               # Organizamos las actividades en función del orden establecido por la hormiga
               matriz_actividades = df_datos.groupby('Paciente')['Actividad'].apply(list).reindex(pacientes_seleccionados_por_hormiga).tolist() # solucion = [2, 1, 3, 4]
               # Obtener la longitud máxima de las sublistas en Pu_ordenado
               longitud_maxima = max(map(len, matriz_actividades))
               # Rellenar con ceros las sublistas que no llegan al máximo para poder transponerla sin perder actividades
               Pu_transpuesto = [sublista + ['0'] * (longitud_maxima - len(sublista)) for sublista in matriz_actividades]

                # Transponer la lista resultante
               Pu_transpuesto = list(map(list, zip(*Pu_transpuesto)))
               # Obtenemos la matriz de Pu sin los ceros
               rep_solucion = []
               for i in Pu_transpuesto:
                  for j in i:
                    if j!='0':
                      rep_solucion.append(j)


               FO_hormiga, df_datos_unido, df_pacientes = ejecuta_decoding(rep_solucion, df_pacientes, df_recursos_final, df_datos,array_pacientes,TR, R, CR)  # Implementar evaluación de la solución. Calcular su FO
               #FO_hormiga, df_pacientes, df_datos_unido = ejecuta_decoding_pacientes(df_datos ,df_pacientes, pacientes_seleccionados_por_hormiga)  # Implementar evaluación de la solución. Calcular su FO
               soluciones.append(pacientes_seleccionados_por_hormiga)
               calidad_soluciones.append(calcular_calidad_solucion(FO_hormiga))  # Implementar evaluación de la solución
               FO_soluciones.append(FO_hormiga)


        # Opcional: Imprimir el mejor camino y su costo de la iteración
        #indice_mejor_hormiga = calidad_soluciones.index(max(calidad_soluciones))
        indice_mejor_hormiga = FO_soluciones.index(min(FO_soluciones))
        mejor_solucion.append(soluciones[indice_mejor_hormiga])
        mejor_solucion_calidad.append(calidad_soluciones[indice_mejor_hormiga])
        mejor_solucion_FO.append(FO_soluciones[indice_mejor_hormiga])
        df.loc[len(df)] = [iteracion, FO_soluciones[indice_mejor_hormiga],'ACO4']
        #print('FO:', FO_soluciones[indice_mejor_hormiga], 'Rep_sol:', soluciones[indice_mejor_hormiga])

        # Actualiza la matriz de feromonas con la mejor solucion encontrada
        matriz_feromonas = actualizar_feromonas_pacientes(matriz_feromonas, soluciones[indice_mejor_hormiga], calidad_soluciones[indice_mejor_hormiga],ro)

        if iteracion >= 3 and len(set(mejor_solucion_FO[-3:])) == 1:
          bl = 1
          best_sol_bl , best_FO_bl = busqueda_local(solucion_inicial, df_datos, df_pacientes, df_recursos_final,TR, R, CR)
          #print('nueva solucion', best_sol_bl)

        # Contador de mejores soluciones
        for index, row in df.iterrows():
            current_value = row['FO']
            if current_value < best_value:
                best_value = current_value
                counter += 1

    # Devuelve el mejor camino y su costo después de todas las iteraciones
    #mejor_solucion_global = mejor_solucion[mejor_solucion_calidad.index(max(mejor_solucion_calidad))]
    mejor_solucion_global = mejor_solucion[mejor_solucion_FO.index(min(mejor_solucion_FO))]
    mejor_FO = min(mejor_solucion_FO)
    return mejor_solucion_global, df, mejor_FO, counter,df_datos_unido