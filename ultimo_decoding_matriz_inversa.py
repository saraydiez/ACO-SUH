# -*- coding: utf-8 -*-
"""ULTIMO Decoding_matriz_inversa.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Mz2WAlqxRCKqxX3wGzZMb3IKJg-NgqkI

Nuevas funcionalidades:

- ~Calcular saturacion ANTES de programar en el tiempo~
- ~Guardar datos de las ejecuciones para poder jugar con ellos~
- CALIBRAR nº iteraciones y nº hormigas
- ~Leer documentos ACO para ver qué parametros usan (preferiblemente de programacion de tareas)~
- ~Probar decoding SIN ordenarla matriz trasponiendola (por pacientes a saco)~
"""

!rm datos_pacientes.csv df_datos.csv  df_recursos_final.csv df_recursos_ocupados.csv  lista_prioridades.json  orden_actividades_por_paciente.json results.csv

from google.colab import files

uploaded = files.upload()

"""# FUNCIONES

## De constantes
"""

import pandas as pd
import plotly.express as px
import pandas as pd
import numpy as np
from datetime import datetime, timedelta
import random
import copy
from operator import itemgetter
import math

def establece_prioridad(numero_pacientes, max_prioridad):
  ESI = range(1,max_prioridad+1)
  probabilidades = [0.76, 11.26, 48.86, 37.16, 1.96]

  # Normalizar las probabilidades
  probabilidades_normalizadas = [p / sum(probabilidades) for p in probabilidades]

  array_prioridades = np.random.choice(ESI, numero_pacientes, p=probabilidades_normalizadas)
  return array_prioridades

def define_tepcof_paciente(prioridad, TEPCOF):
    valor=0
    if prioridad==1:
        valor=TEPCOF['1']

    elif prioridad==2:

        valor=TEPCOF['2']

    elif prioridad==3:
        valor=TEPCOF['3']

    elif prioridad==4:
        valor=TEPCOF['4']

    elif prioridad==5:
        valor=TEPCOF['5']

    return valor

"""## Generamos datos paciente

Tenemos 4 tipos de paciete:
1.  Pacientes que han llegado en el instante que se han lanzado el programa (intante 0):
  - t_espera = 0
2.  Pacientes que han llegado antes y aún no han sido atendidos:
  - t_espera > 0
3.  Pacientes que ya han sido atendidos en alguna actividad de sus PU (estan en sala de espera)
 - No importa el tiempo de espera, se tratarán solamente para organizarlos
 - ¿Mayor prioridad que los que han venido después?
4.  Pacientes que están siendo atendidos en esos momentos:
  - están ocupando algún reurso , por lo tanto ese recurso no estará disponible en el instante 0
"""

def generar_pacientes_y_recursos(array_prioridades, procesos_por_prioridad, TEPCOF, tipos_recursos, recursos):
    pacientes = []
    recursos_ocupados = []
    PU_i = []
    matriz = []
    disponible = copy.copy(tipos_recursos)
    recursos_disponibles = copy.copy(recursos)
    pacientes_tipo_4 = 0
    act=0
    orden_actividades_por_paciente = {}

    ### Recorre paciente a paciente
    for paciente_id , prioridad in enumerate(array_prioridades,1):

      ## Asigna PU de procesos_por_prioridad
      PU_i = (procesos_por_prioridad[prioridad])

      TEPCOF_i = define_tepcof_paciente(prioridad, TEPCOF)

      tipo_paciente = random.choice([1, 2, 3, 4])




    ## Elige tipo_paciente // con todo lo que conlleva
    # Actualiza PU


      if tipo_paciente == 1:
          paciente = {
              "Paciente": paciente_id,
              "TEPCOF": TEPCOF_i,
              "Prioridad": prioridad,
              "t_llegada": 0,
              "visto": 0,
              "t_disponible": 0,
              "tipo_paciente":1,
              "PU": [sublista[0] for sublista in PU_i]
            }
      elif tipo_paciente == 2:
          t_llegada_max = TEPCOF_i * (1+(prioridad/5))
          t_llegada = math.ceil(random.uniform(1, t_llegada_max))

          paciente = {
              "Paciente": paciente_id,
              "TEPCOF": TEPCOF_i,
              "Prioridad": prioridad,
              "t_llegada": t_llegada,
              "visto": 0,
              "t_disponible": 0,
              "tipo_paciente":2,
              "PU": [sublista[0] for sublista in PU_i]
            }

      elif tipo_paciente == 3:

          PU_last = PU_i[:][:-1]
          punto_parada = random.choice(PU_last)
          indice_sublista = PU_i.index(punto_parada)

          # Crear la nueva lista a partir del índice encontrado
          nuevo_PU_i = PU_i[indice_sublista + 1:]
          #nuevo_PU_i = [actividad for actividad in PU_i if actividad >= recurso_elegido]

          PU_i = nuevo_PU_i

          paciente = {
              "Paciente": paciente_id,
              "TEPCOF": None,
              "Prioridad": prioridad,
              "t_llegada": None,
              "visto": 1,
              "t_disponible": 0,
              "tipo_paciente": 3,
              "PU": [sublista[0] for sublista in PU_i]
            }

      else:

            PU_last = PU_i[:][:-1]
            flag = 0

            # Elegimos una actividad que esté dentro del PU de ese paciente
            ## Falta algo para
            for i in range(0, len(PU_last)): # Vamos recorriendo actividad por actividad para ver si en alguna hay recursos dispo
                recurso_elegido = PU_last[i]
                if int(recurso_elegido[1]) <= int(disponible[recurso_elegido[0]]): # Si hay disponibles, deja de buscar
                    flag = 1
                    break

            if flag == 1: # Será un paciente de tipo 4
              pacientes_tipo_4 += 1
              # Encontrar el índice de la sublista en la lista original
              indice_sublista = PU_i.index(recurso_elegido)

              # Crear la nueva lista a partir del índice encontrado
              nuevo_PU_i = PU_i[indice_sublista + 1:]
              #nuevo_PU_i = [actividad for actividad in PU_i if actividad >= recurso_elegido]
              PU_i = nuevo_PU_i

              t_disponible = math.ceil(random.uniform(1, recurso_elegido[3])) # Poner algo en función del recurso que ocupa ?¿? poner mitad del tiempo de la actividad ¿?¿? EN ESE CASO ELEGIR ACTIVIDAD PRIMERO
              paciente = {
                "Paciente": paciente_id,
                "TEPCOF": None,
                "Prioridad": prioridad,
                "t_llegada": None,
                "visto": 1,
                "t_disponible": t_disponible,
                "tipo_paciente": 4,
                "PU": list(map(itemgetter(0), PU_i))
              }

              if not recurso_elegido[0].startswith('LAB'): # Si es LAB no 'bloqueamos' el recurso
                  disponible[recurso_elegido[0]] -= 1
                  # aqui toca especificar el recurso (CON1, CON2...)
                  for i in recursos_disponibles:
                      if i.startswith(recurso_elegido[0]):
                          recurso_ocupado = {
                            "recurso": i,
                            "t_disponible": t_disponible,
                            "TR": recurso_elegido[0]
                          }
                          recursos_disponibles.remove(i) #par el DF de recursos
                          recursos_ocupados.append(recurso_ocupado) # Para el DataFrame
                          break

            else: # si no hay recursos disponibles para ese paciente, será paciente de tipo 2
                  t_llegada_max = TEPCOF_i * (1+(prioridad/5))
                  t_llegada = random.uniform(1, t_llegada_max)

                  paciente = {
                      "Paciente": paciente_id,
                      "TEPCOF": TEPCOF_i,
                      "Prioridad": prioridad,
                      "t_llegada": t_llegada,
                      "visto": 0,
                      "t_disponible": 0,
                      "tipo_paciente":2,
                      "PU": list(map(itemgetter(0), PU_i))
                    }

      pacientes.append(paciente)

      # Establecemos tiempos actividades
      array_actividades = []
      for actividad in PU_i:
          act+=1
          tiempo = math.ceil(random.triangular(int(actividad[2]), int(actividad[4]), int(actividad[3])))
          matriz.append({
                  'Actividad': act,
                  'Paciente': paciente_id,
                  'Prioridad': prioridad,
                  'TR': actividad[0],
                  'Recursos_Necesarios': actividad[1],
                  'Tiempo': tiempo
              })
          array_actividades.append(act)
      orden_actividades_por_paciente[paciente_id] = array_actividades # esto solo lo queremos para ACO_Actividades

    # Crear DataFrame de pacientes
    df_pacientes = pd.DataFrame(pacientes)
    # 1. Ordenar el DataFrame por la columna 'Visto', de tal manera que salgan los ya atendidos primero
    df_pacientes = df_pacientes.sort_values(by='visto', ascending=False)
    # 2.Ordenamos por prioridad
    df_pacientes = df_pacientes.sort_values(by='Prioridad', ascending=True)

    # Crear DataFrame de recursos ocupados
    df_recursos_ocupados = pd.DataFrame(recursos_ocupados)

    # Crear DataFrame de todos los recursos con t_disponible = 0 para aquellos que no estén en df_recursos_ocupados
    df_recursos_totales = pd.DataFrame([{"recurso": recurso, "t_disponible": 0} for recurso in recursos])

    #Combinar DataFrames para obtener el DataFrame final de recursos
    if len(df_recursos_ocupados) > 0:
      df_ocupados = df_recursos_ocupados.drop('TR', axis=1)
      df_recursos_final = pd.concat([df_recursos_totales, df_ocupados], ignore_index=True).groupby("recurso").max().reset_index()

    else:
      df_recursos_final = df_recursos_totales

    # DF datos
    df_datos = pd.DataFrame(matriz)


    return df_pacientes, df_recursos_final, recursos, df_datos, df_recursos_ocupados, orden_actividades_por_paciente

"""## De acción

Para hacerlo 'general', tendríamos que añadir variables en el DataFrame de tal manera que si en la columna 'X' hay un 'Si' , significa que ese recurso no tiene límite de actividades que hacer a la vez:
En el recurso 'LAB' se pueden hacer varios analisis a la vez, ¿poner máximo?

De otra forma podríamos hacer que si el recurso es 'LAB' se meta siempre que el paciente ya este disponible (no mire el tiempo_fin_recurso['LAB']



---
Por otro lado podríamos añadir otra variable llamada 'Número de recursos' que indique la cantidad de recursos necesarios para esa actividad.
En caso de necesitar 2, tendrá que buscar aquel hueco en el que 2 recursos del mismo tipo estén disponibles **a la vez**


---
También es necesario que se guarde la variable 'Recurso consulta' para cada paciente de tal manera que un mismo paciente siempre tenga el mismo facultativo en la consulta
"""

def asigna_recurso(tipos_recurso, recursos_disponibles, capacidad_recursos, recurso_actividad, actividad ,tiempo_paciente, tiempo_actividad, paciente, cantidad_recurso_actividad, tiempos_finalizacion_recurso, tiempos_finalizacion_paciente, consultas_asignadas,tiempos_finalizacion_actividad,tiempo_inicio_actividad, recurso_asignado):
  asignado=0
  # Me quedo con la copia para los for (da error por cambiar el array)
  recursos = copy.copy(recursos_disponibles) # [CON1, ENF1,...]
  recursos_tipo_disponibles = {}
  recursos_tipo_no_disponibles = {}
  recursos_asignados = []
  asigna_consulta = 0

# Me quedo siempre con aquellos recursos que terminan antes (tantos como necesite la actividad)
## Luego me quedo con el tiempo max entre todos

# Cuando la actividad es de consulta, siempre se va a necesitar 1 recurso
  if recurso_actividad in ['CON','ACON']:
    if consultas_asignadas[paciente] == 0: # Si aun no se le ha asignado una consulta a ese paciente
     for recurso in recursos:
        if recurso.startswith(recurso_actividad):
          tiempo = tiempos_finalizacion_recurso.get(recurso,0)
          recursos_tipo_disponibles[recurso] = tiempo # guardamos el recurso en un diccionario con su tiempo de disponibilidad para comparar

     asigna_consulta = 1

    else:
      recurso = consultas_asignadas[paciente]
      tiempo = tiempos_finalizacion_recurso.get(recurso,0)
      recursos_tipo_disponibles[recurso] = tiempo


  else:
    for recurso in recursos:

      if recurso.startswith(recurso_actividad):

          # Mirar si se trata de un recurso cuya capacidad está limitada o no
          ## Si tiene capacidad infinita, se mete cuando el paciente lo requiere (deja de buscar)
          if capacidad_recursos[recurso_actividad] > 1:
            recursos_tipo_disponibles[recurso] = 0 # ponemos 0 para que sea siempre menor que tiempo_paciente
            asignado +=1
            break

          else:
            # Si capacidad no es infinita
            # Me guardo el recurso con su tiempo
            tiempo = tiempos_finalizacion_recurso.get(recurso,0)
            recursos_tipo_disponibles[recurso] = tiempo


  # De los recursos tipo que hay, necesito los que terminan antes ¿SIEMPRE?
  tiempo_inicio = 0
  for i in range(cantidad_recurso_actividad):
     # Ver cuando se libera ANTES alguno de los recursos
      clave_minima = min(recursos_tipo_disponibles, key=lambda k: recursos_tipo_disponibles[k])

      # Guardamos el tiempo del recurso para compararlo con proximos recursos si fuese necesario
      tiempo_inicio_ant = tiempo_inicio
      # La actividad empezará cuando paciente y recurso estén disponibles (tiempo mayor entre los dos)
      tiempo_inicio = max(tiempos_finalizacion_recurso.get(clave_minima,0), tiempo_paciente, tiempo_inicio_ant)

      # Lo guardamos en el array de recursos que sí vamos a asignar
      recursos_asignados.append(clave_minima)
      # Lo eliminamos para que ya no sea el valor mas pequeño del diccionario
      del recursos_tipo_disponibles[clave_minima]

  # Terminado el bucle for tiempo_inicio = tiempo mínimo para empezar la actividad y que tanto paciente y recurso(s) estén disponibles
  # Guardamos el tiempo de inicio de la actividad y de finalización para posteriormente el GANTT
  tiempo_inicio_actividad[actividad] = tiempo_inicio
  tiempos_finalizacion_actividad[actividad] = tiempo_inicio + tiempo_actividad

  # Guardamos el tiempo en el que los recursos y paciente se liberarán tras esta actividad
  for clave in recursos_asignados:
    tiempos_finalizacion_recurso[clave]= (tiempo_inicio + tiempo_actividad)

    if asigna_consulta == 1: # Que ese paciente aun no tiene consulta asignada
      consultas_asignadas[paciente] = clave

  tiempos_finalizacion_paciente[paciente] = tiempo_inicio + tiempo_actividad

  # Guardamos el recurso que se ha asignado a la actividad para el GANTT
  recurso_asignado[actividad] = [clave for clave in recursos_asignados]

"""Por último, se calcula el tiempo que ha sido ocupado cada recurso y se calcula la saturación de cada tipo de recurso, determinada por dicha ocupación, por el número de recursos que hay para el tipo de recurso correspondiente y del LOS para el que se está realizando la optimización.

Se estudian 3 escenarios: 50%, 75% y 100% de saturación máxima. De esta manera, para estos valores de saturación, se generan iterativamente pacientes, de uno en uno, hasta que la saturación de alguno de los recursos llegue al valor establecido.
"""

def calcula_saturacion(df_datos, df_recursos_ocupados, nivel,tipos_recurso):
  ocupacion_recursos = {}
  saturacion = {}
  LOSmedio = ((3.15+3.14+2.86+1.49+1.31)*60)/5
  flag = 0
  # Iterar sobre las filas del DataFrame y calcular la ocupación acumulada de cada recurso
  for index, row in df_datos.iterrows():
      recurso = row['TR']
      tiempo_actividad = row['Tiempo']


      # Si el recurso ya está en el diccionario, sumar el tiempo de esta actividad
      if recurso in ocupacion_recursos:
          ocupacion_recursos[recurso] += tiempo_actividad
      # Si el recurso no está en el diccionario, agregarlo con el tiempo de esta actividad
      else:
          ocupacion_recursos[recurso] = tiempo_actividad

  for index, row in df_recursos_ocupados.iterrows():
    recurso = row['TR']
    t_ocupado = row['t_disponible']
    if recurso in ocupacion_recursos:
        ocupacion_recursos[recurso] += t_ocupado
    else:
        ocupacion_recursos[recurso] = t_ocupado

  # Mostrar la ocupación acumulada de cada recurso
  for recurso, ocupacion in ocupacion_recursos.items():
      n = tipos_recurso[recurso]
      sat = LOSmedio * n
      saturacion[recurso] = (ocupacion/sat)*100
      print(f"Recurso {recurso}: Ocupación acumulada = {ocupacion} minutos, saturación = {saturacion[recurso]}")
      if saturacion[recurso] > nivel:
          flag = 1

  return flag

def FO_solucion(df_pacientes, tiempo_final_paciente):
  max_value = 0
  tepcof_FO =0
  clave_maxima, maximo_valor = max(tiempo_final_paciente.items(), key=lambda x: x[1])
  for index, row in df_pacientes.iterrows():
    t_llegada = row['t_llegada']
    tepcof = row['TEPCOF_real']
    epcof = row['TEPCOF']
    prioridad = row['Prioridad']
    if t_llegada != None:
      if t_llegada >= max_value :
        max_value = t_llegada
      if tepcof > epcof:
        tepcof_FO += tepcof * (6-prioridad)

  FO = maximo_valor + max_value + tepcof_FO
  return FO

def calcula_TEPCOF(df_pacientes, df_datos_unido):
  # Itera sobre las filas del DataFrame
  for index1, row1 in df_pacientes.iterrows():
        tiempo_primera_actividad = 1000
        if row1['visto'] == 0:
          a = row1['Paciente']
          b = row1['t_llegada']
          # Guardamos el tiempo de su primera actividad (el tiempo de inicio mas pequeño)
          for index2, row2 in df_datos_unido.iterrows():
            if row2['Paciente'] == a:
              t_inicio = df_datos_unido.loc[index2,'Tiempo_inicio']
              if t_inicio < tiempo_primera_actividad:
                tiempo_primera_actividad = t_inicio

          calculo = tiempo_primera_actividad + b
        else:
          calculo = None


        # Añadimos el dato en una nueva columna, en el indice correspondiente del primer DataFrame

        df_pacientes.at[index1, 'TEPCOF_real'] = calculo

  return df_pacientes

def ejecuta_decoding(rep_solucion, array_prioridades, df_pacientes, df_recursos_final, df_datos):
  # Diccionarios (clave: valor) para mayor legibilidad de los resultados
  tiempo_inicio_actividad={}
  tiempos_finalizacion_actividad={}
  consultas_asignadas = {}
  recurso_asignado={}

  # Inicializamos las consultas asignadas a cada paciente
  for i in range(len(array_prioridades)):
     consultas_asignadas[i+1] = 0 # paciente 1: CON1, paciente 2: CON2 ...
  # Inicializamos las consultas asignadas a cada paciente

    # Seleccionar las columnas de interés
  columna_clave = 'Paciente'
  columna_valor = 't_disponible'

    # Crear el diccionario
  tiempo_final_paciente = df_pacientes.set_index(columna_clave)[columna_valor].to_dict()

    # Seleccionar las columnas de interés
  columna_clave2 = 'recurso'
  columna_valor2 = 't_disponible'

    # Crear el diccionario
  tiempo_final_recurso = df_recursos_final.set_index(columna_clave2)[columna_valor2].to_dict()

  ## Bucle que organiza actividades en orden de la solucion
  for actividad in rep_solucion:
        # ¿Qué tipo de recurso necesita la actividad?
        indice = df_datos.loc[df_datos['Actividad'] == actividad].index.item()
        paciente, tipo, cantidad_recurso_actividad, tiempo_actividad = df_datos.loc[indice,['Paciente','TR','Recursos_Necesarios','Tiempo']]
        tiempo_p = tiempo_final_paciente.get(paciente,0)

        asigna_recurso(TR, R, CR, tipo, actividad ,tiempo_p, tiempo_actividad, paciente, cantidad_recurso_actividad, tiempo_final_recurso, tiempo_final_paciente, consultas_asignadas,tiempos_finalizacion_actividad,tiempo_inicio_actividad, recurso_asignado)

  data_list = []
  for key, value in tiempos_finalizacion_actividad.items():
          data_list.append({'Actividad': key, 'Recurso_asignado': recurso_asignado[key],'Tiempo_inicio':tiempo_inicio_actividad[key], 'Tiempo_FIN': value})
  Data_pacientes = pd.DataFrame(data_list)
  df_datos_unido = pd.merge(df_datos, Data_pacientes, on='Actividad', how='inner')
  #####################################################################################
  ### Calcula TEPCOF:
  df_pacientes = calcula_TEPCOF(df_pacientes, df_datos_unido)

  #### Calcula FO
  FO=FO_solucion(df_pacientes, tiempo_final_paciente)

  return FO, df_datos_unido, df_pacientes
  ###############################################################

def representa_GANTT(df_datos_unido):
  df_expanded = df_datos_unido.explode('Recurso_asignado')
  #Obtener la fecha actual
  fecha_actual = datetime.now()

  # Convertir los tiempos de inicio y fin en formato datetime para Plotly
  df_expanded['Inicio'] =  fecha_actual + pd.to_timedelta(df_expanded['Tiempo_inicio'], unit='m')
  df_expanded['Fin'] =  fecha_actual + pd.to_timedelta(df_expanded['Tiempo_FIN'], unit='m')


  # Generar colores aleatorios para los pacientes
  unique_patients = df_expanded['Paciente'].unique()
  colors = {patient: f'#{random.randint(0, 0xFFFFFF):06x}' for patient in unique_patients}

  # Crear una nueva columna 'Leyenda' para el color de la leyenda
  df_expanded['Leyenda'] = df_expanded['Paciente'].apply(lambda x: f'Paciente {x}')


  # Generar el diagrama de Gantt
  fig = px.timeline(df_expanded, x_start='Inicio', x_end='Fin', y='Recurso_asignado', text='Actividad', color='Leyenda', color_discrete_map={f'Paciente {k}': v for k, v in colors.items()},
                    title='Diagrama de Gantt')

  # Actualizar el layout para mostrar el eje X con la fecha y hora
  #fig.update_layout(xaxis=dict(tickformat='%Y-%m-%d %H:%M'))

  # Mostrar el diagrama
  fig.show()
  return

"""# Representación GANTT

## Representación tipo 1
"""

pip install matplotlib seaborn pandas

import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd
from matplotlib.ticker import FuncFormatter

# Asignar colores aleatorios a los pacientes
paciente_colores = {paciente: sns.color_palette('husl', n_colors=df_datos_unido['Paciente'].nunique())[i]
                    for i, paciente in enumerate(df_datos_unido['Paciente'].unique())}

# Crear el diagrama de Gantt
fig, ax = plt.subplots(figsize=(10, 6))

for index, row in df_datos_unido.iterrows():
    paciente_color = paciente_colores[row['Paciente']]
    recursos = row['Recurso_asignado']

    for recurso in recursos:
        ax.barh(y=recurso, left=row['Tiempo_inicio'], width=row['Tiempo_FIN'] - row['Tiempo_inicio'],
                color=paciente_color, edgecolor='black')


# Configuraciones estéticas
ax.set_xlabel('Tiempo (minutos)')
ax.set_ylabel('Recursos asignados')
ax.set_title('Diagrama de Gantt')

# Ajustar el eje X para mostrar minutos desde 00:00:00
minutos_inicio = df_datos_unido['Tiempo_inicio'].min()
minutos_fin = df_datos_unido['Tiempo_FIN'].max()
ax.set_xlim(minutos_inicio, minutos_fin)



# Crear leyenda para los colores de los pacientes
handles = [plt.Rectangle((0, 0), 1, 1, color=color) for color in paciente_colores.values()]
labels = [f'Paciente {paciente}' for paciente in paciente_colores.keys()]
ax.legend(handles, labels, loc='upper left')

plt.show()

"""## Representación tipo 2"""

pip install plotly

from datetime import datetime, timedelta


# Expandir las filas para cada recurso asignado
df_expanded = df_datos_unido.explode('Recurso_asignado')

# Obtener la fecha actual
fecha_actual = datetime.now()

# Convertir los tiempos de inicio y fin en formato datetime para Plotly
df_expanded['Inicio'] =  fecha_actual + pd.to_timedelta(df_expanded['Tiempo_inicio'], unit='m')
df_expanded['Fin'] =  fecha_actual + pd.to_timedelta(df_expanded['Tiempo_FIN'], unit='m')


# Generar colores aleatorios para los pacientes
unique_patients = df_expanded['Paciente'].unique()
colors = {patient: f'#{random.randint(0, 0xFFFFFF):06x}' for patient in unique_patients}

# Crear una nueva columna 'Leyenda' para el color de la leyenda
df_expanded['Leyenda'] = df_expanded['Paciente'].apply(lambda x: f'Paciente {x}')


# Generar el diagrama de Gantt
fig = px.timeline(df_expanded, x_start='Inicio', x_end='Fin', y='Recurso_asignado', text='Actividad', color='Leyenda', color_discrete_map={f'Paciente {k}': v for k, v in colors.items()},
                  title='Diagrama de Gantt')

# Actualizar el layout para mostrar el eje X con la fecha y hora
#fig.update_layout(xaxis=dict(tickformat='%Y-%m-%d %H:%M'))

# Mostrar el diagrama
fig.show()

df_pacientes

# AÑADIR ESTOS TIEMPOS PARA LA SATURACIÓN:

df_recursos_ocupados

df_expanded

"""# INICIALIZACION VARIABLES"""

import pandas as pd
import plotly.express as px
import random
from datetime import datetime, timedelta

I = 0
flag = 0


#franja = 0 # a partir de las 12 am
franja = 1 # a partir de las 6am
if franja==0:
    procesos_por_prioridad = {
            1: [['ENF', 2, 20, 30, 75],
                ['CON',1, 10, 20, 25],
                ['LAB', 1, 20,35,45],
                ['RAY',1, 3, 5, 15],
                ['ENF', 2,  20,30, 40],
                ['CON', 1, 20,30, 40]],
            2: [['ENF', 2, 18, 28, 45],
                ['CON',1, 10, 20, 25],
                ['LAB', 1, 3, 5, 15],
                ['RAY',1, 5, 10, 20],
                ['ENF', 2, 15, 20, 30],
                ['CON', 1, 15, 20, 25 ]],
            3: [['ENF', 1, 15, 22, 30],
                ['CON',1, 5, 15, 20],
                ['LAB', 1, 3, 5, 15],
                ['RAY',1, 5, 10, 20],
                ['ENF', 1, 10, 15, 20],
                ['CON', 1, 8, 15, 18]],
            4: [['ENF', 1, 5, 10, 20],
                ['ACON',1, 2, 3, 5],
                ['RAY',1, 2, 5, 10],
                ['ENF', 1, 5, 8, 12 ],
                ['ACON', 1, 5, 10, 15]],
            5: [['ENF', 1, 2, 4, 8],
                ['ACON',1, 2, 3, 5]]
      }
    TR={'CON':2,'ENF':9,'RAY':1,'LAB':1 ,'ACON':2}
    R=['CON1','CON2','ENF1','ENF2','ENF3','ENF4','ENF5','ENF6','ENF7','ENF8','ENF9','RAY','LAB','ACON1','ACON2']

else:
    procesos_por_prioridad = {
          1: [['ENF', 2, 20, 30, 75],
              ['CON',1, 10, 20, 25],
              ['LAB', 1, 20,35,45],
              ['RAY',1, 3, 5, 15],
              ['ENF', 2,  20,30, 40],
              ['CON', 1, 20,30, 40]],
          2: [['ENF', 2, 18, 28, 45],
              ['CON',1, 10, 20, 25],
              ['LAB', 1, 3, 5, 15],
              ['RAY',1, 5, 10, 20],
              ['ENF', 2, 15, 20, 30],
              ['CON', 1, 15, 20, 25 ]],
          3: [['ENF', 1, 15, 22, 30],
              ['CON',1, 5, 15, 20],
              ['LAB', 1, 3, 5, 15],
              ['RAY',1, 5, 10, 20],
              ['ENF', 1, 10, 15, 20],
              ['CON', 1, 8, 15, 18]],
          4: [['ENF', 1, 5, 10, 20],
              ['CON',1, 2, 3, 5],
              ['RAY',1, 2, 5, 10],
              ['ENF', 1, 5, 8, 12 ],
              ['CON', 1, 5, 10, 15]],
          5: [['ENF', 1, 2, 4, 8],
              ['CON',1, 2, 3, 5]]
    }
    TR={'CON':1,'ENF':6,'RAY':1,'LAB':1}
    R=['CON1','ENF1','ENF2','ENF3','ENF4','ENF5','ENF6','RAY','LAB']

TEPCOF = {'1':0, '2': 15, '3':60, '4':120, '5': 240}
CR ={'CON':1,'ENF':1,'RAY':1,'LAB':float('inf') ,'ACON':1} # Capacidad de los recursos
nivel_sat = 100 #50,75,100
#########################################################################
#for instancia in range(10)
# Generamos pacientes:

while flag ==0:
    I += 1
    array_prioridades = establece_prioridad(I, 5)
    df_pacientes, df_recursos_final, recursos, df_datos, df_recursos_ocupados, orden_actividades_por_paciente = generar_pacientes_y_recursos(array_prioridades, procesos_por_prioridad, TEPCOF, TR, R )
    flag = calcula_saturacion(df_datos, df_recursos_ocupados, nivel_sat,TR)

df_datos

# Guardamos datos de prueba
import json
df_pacientes.to_csv('datos_pacientes.csv', index=False)
df_recursos_final.to_csv('df_recursos_final.csv', index=False)
df_datos.to_csv('df_datos.csv', index=False)
df_recursos_ocupados.to_csv('df_recursos_ocupados.csv', index=False)
# Guardar el diccionario en un archivo JSON
with open('orden_actividades_por_paciente.json', 'w') as archivo:
    json.dump(orden_actividades_por_paciente, archivo)

# Convertir el ndarray a una lista de Python
lista_prioridades = array_prioridades.tolist()
with open('lista_prioridades.json', 'w') as archivo:
    json.dump(lista_prioridades, archivo)

df_pacientes

df_recursos_ocupados

df_recursos_final

"""# IMPORTAR DATOS DE PRUEBA"""

franja = 0 # a partir de las 12 am
#franja = 1 # a partir de las 6am
if franja==0:
    procesos_por_prioridad = {
            1: [['ENF', 2, 20, 30, 75],
                ['CON',1, 10, 20, 25],
                ['LAB', 1, 20,35,45],
                ['RAY',1, 3, 5, 15],
                ['ENF', 2,  20,30, 40],
                ['CON', 1, 20,30, 40]],
            2: [['ENF', 2, 18, 28, 45],
                ['CON',1, 10, 20, 25],
                ['LAB', 1, 3, 5, 15],
                ['RAY',1, 5, 10, 20],
                ['ENF', 2, 15, 20, 30],
                ['CON', 1, 15, 20, 25 ]],
            3: [['ENF', 1, 15, 22, 30],
                ['CON',1, 5, 15, 20],
                ['LAB', 1, 3, 5, 15],
                ['RAY',1, 5, 10, 20],
                ['ENF', 1, 10, 15, 20],
                ['CON', 1, 8, 15, 18]],
            4: [['ENF', 1, 5, 10, 20],
                ['ACON',1, 2, 3, 5],
                ['RAY',1, 2, 5, 10],
                ['ENF', 1, 5, 8, 12 ],
                ['ACON', 1, 5, 10, 15]],
            5: [['ENF', 1, 2, 4, 8],
                ['ACON',1, 2, 3, 5]]
      }
    TR={'CON':2,'ENF':9,'RAY':1,'LAB':1 ,'ACON':2}
    R=['CON1','CON2','ENF1','ENF2','ENF3','ENF4','ENF5','ENF6','ENF7','ENF8','ENF9','RAY','LAB','ACON1','ACON2']

else:
    procesos_por_prioridad = {
          1: [['ENF', 2, 20, 30, 75],
              ['CON',1, 10, 20, 25],
              ['LAB', 1, 20,35,45],
              ['RAY',1, 3, 5, 15],
              ['ENF', 2,  20,30, 40],
              ['CON', 1, 20,30, 40]],
          2: [['ENF', 2, 18, 28, 45],
              ['CON',1, 10, 20, 25],
              ['LAB', 1, 3, 5, 15],
              ['RAY',1, 5, 10, 20],
              ['ENF', 2, 15, 20, 30],
              ['CON', 1, 15, 20, 25 ]],
          3: [['ENF', 1, 15, 22, 30],
              ['CON',1, 5, 15, 20],
              ['LAB', 1, 3, 5, 15],
              ['RAY',1, 5, 10, 20],
              ['ENF', 1, 10, 15, 20],
              ['CON', 1, 8, 15, 18]],
          4: [['ENF', 1, 5, 10, 20],
              ['CON',1, 2, 3, 5],
              ['RAY',1, 2, 5, 10],
              ['ENF', 1, 5, 8, 12 ],
              ['CON', 1, 5, 10, 15]],
          5: [['ENF', 1, 2, 4, 8],
              ['CON',1, 2, 3, 5]]
    }
    TR={'CON':1,'ENF':6,'RAY':1,'LAB':1}
    R=['CON1','ENF1','ENF2','ENF3','ENF4','ENF5','ENF6','RAY','LAB']

TEPCOF = {'1':0, '2': 15, '3':60, '4':120, '5': 240}
CR ={'CON':1,'ENF':1,'RAY':1,'LAB':float('inf') ,'ACON':1} # Capacidad de los recursos

import pandas as pd
import json
import io

# Asegúrate de reemplazar 'mi_archivo.csv' con el nombre real de tu archivo
df_pacientes = pd.read_csv(io.BytesIO(uploaded['datos_pacientes.csv']))
df_datos = pd.read_csv(io.BytesIO(uploaded['df_datos.csv']))
df_recursos_final = pd.read_csv(io.BytesIO(uploaded['df_recursos_final.csv']))
df_recursos_ocupados = pd.read_csv(io.BytesIO(uploaded['df_recursos_ocupados.csv']))
orden_actividades_por_paciente= json.load(io.BytesIO(uploaded['orden_actividades_por_paciente.json']))

# Convertir las claves a enteros
orden_actividades_por_paciente = {int(k): v for k, v in orden_actividades_por_paciente.items()}

lista_prioridades = json.load(io.BytesIO(uploaded['lista_prioridades.json']))

# Convertir la lista a un ndarray
array_prioridades = np.array(lista_prioridades)

df_pacientes

"""# GENERAR SOLUCION"""

##########################################################################
# PRIMERA representación de la solución:

array_pacientes = df_pacientes['Paciente'].values
# Agrupar actividades por paciente
matriz_actividades = df_datos.groupby('Paciente')['Actividad'].apply(list).reindex(array_pacientes).tolist()

# Obtener la longitud máxima de las sublistas en Pu_ordenado
longitud_maxima = max(map(len, matriz_actividades))
# Rellenar con ceros las sublistas que no llegan al máximo para poder transponerla sin perder actividades
Pu_transpuesto = [sublista + ['0'] * (longitud_maxima - len(sublista)) for sublista in matriz_actividades]

# Transponer la lista resultante
Pu_transpuesto = list(map(list, zip(*Pu_transpuesto)))

# Obtenemos la matriz de Pu sin los ceros
rep_solucion_1 = []
for i in Pu_transpuesto:
  for j in i:
    if j!='0':
      rep_solucion_1.append(j)

print(rep_solucion_1)
########################################################################

FO_inicial_1, df_datos_unido, df_pacientes = ejecuta_decoding(rep_solucion_1, array_prioridades, df_pacientes, df_recursos_final, df_datos)

#### Calcula FO

representa_GANTT(df_datos_unido)
###############################################################

FO_inicial_1

len(df_datos)

(((30*15) /2)*375)/1000 # 9 RECURSOS TIENE EL SUH A LAS 6H

df_pacientes

len(df_datos)

(((len(df_datos)*15) /2)*375)/1000

df_datos_unido

# SEGUNDO TIPO DE REP-PACIENTES
array_pacientes = df_pacientes['Paciente'].values
# Agrupar actividades por paciente
matriz_actividades = df_datos.groupby('Paciente')['Actividad'].apply(list).reindex(array_pacientes).tolist()
print(matriz_actividades)
# Obtenemos la matriz de Pu sin los ceros
rep_solucion_2 = []
for i in matriz_actividades:
  for j in i:
    if j!='0':
      rep_solucion_2.append(j)

print(rep_solucion_2)

########################################################################

FO_inicial_2, df_datos_unido, df_pacientes= ejecuta_decoding(rep_solucion_2, array_prioridades, df_pacientes, df_recursos_final, df_datos)

#### Calcula FO

representa_GANTT(df_datos_unido)

FO_inicial_2

array_pacientes

df_pacientes

orden_actividades_por_paciente

"""
# Algoritmo colonia de hormigas por actividades
---


1º Generar una solución inicial basada en la prioridad de los pacientes ✅

2º Inicializar datos algoritmo

3º Actualizar fermonas basandose en la solución inicial dada (como si hubiese sido una primera mejor solución)

4º Realizar tantas iteraciones como se desee.

5º Dentro de cada iteración se generará un numero de hormigas determinado, que se enaluarán y nos quedaremos con la mejor solución

6º aVlver a actualizar feromonas con esa nueva mejor solución


----
ACO 1: primera actividad fija a la de la primera solucion

ACO 2: primera actividad aleatoria entre primeras actividades de los pacientes

ACO 3: primera actividad = primera actividad best_sol hasta ese momento"""

import numpy as np
import random
import matplotlib.pyplot as plt


# Selección de la próxima actividad basada en la regla de transición
def seleccionar_proxima_actividad(alpha, beta, q0, actividades_validas,actividades, feromonas, matriz_costos, orden_actividades_por_paciente, actividades_seleccionadas_por_hormiga):
    """
    Selecciona la próxima actividad basada en la regla de transición del algoritmo ACO, incluyendo la validación
    de que todas las actividades previas de un paciente se hayan completado.

    Parámetros:
    - actividades_validas: Lista de índices de actividades que aún no han sido seleccionadas y son válidas.
    - feromonas: Matriz de feromonas entre actividades.
    - matriz_costos: Matriz de costos entre actividades.
    - orden_actividades_por_paciente: Diccionario que mapea cada paciente a una lista ordenada de sus actividades.
    - actividades_seleccionadas_por_hormiga: Lista de índices de actividades ya seleccionadas por la hormiga.

    Retorna:
    - Índice de la próxima actividad seleccionada o None si no hay transiciones válidas.
    """
    probabilidades = []
    transiciones_validas = []
    actividad_actual = actividades_seleccionadas_por_hormiga[-1]


    for actividad_destino in actividades_validas:
        # Verificar que todas las actividades previas del paciente asociado a esta actividad se hayan completado
        for a in actividades:
          if actividad_destino == a[0]:
            paciente_destino = a[1] # queremos saber el paciente al cual pertenece esa actividad para poder comprobar que se cumple el orden de actividades
            break

        actividades_previas = orden_actividades_por_paciente[paciente_destino][:orden_actividades_por_paciente[paciente_destino].index(actividad_destino)]

        if all(actividad_previa in actividades_seleccionadas_por_hormiga for actividad_previa in actividades_previas):
          transiciones_validas.append(actividad_destino)
    if not transiciones_validas:  # Si no hay transiciones válidas
              return None

    if random.random() < q0:
        #mejor_costo = 0
        mejor_costo = float('inf')
        seleccionado = None

        for actividad_destino in transiciones_validas: # Exploración directa
          #tau = feromonas[int(actividad_actual)-1][int(actividad_destino)-1]  # Cantidad de feromona
          #eta = 1.0 / matriz_costos[int(actividad_actual)-1][int(actividad_destino)-1] if matriz_costos[int(actividad_actual)-1][int(actividad_destino)-1] > 0  else 0  # Valor heurístico. Puede ser inversamente proporcional al costo o a la distancia entre actividades.
          # Considera la inversa del costo por la cantidad de feromona para encontrar el 'mejor' camino
          #if ((tau ** alpha) * (eta ** beta)) > mejor_costo:
          if (matriz_costos[int(actividad_actual)-1][int(actividad_destino)-1]) * feromonas[int(actividad_actual)-1][int(actividad_destino)-1] < mejor_costo:
                #mejor_costo = (tau ** alpha) * (eta ** beta)
                mejor_costo =(matriz_costos[int(actividad_actual)-1][int(actividad_destino)-1]) * feromonas[int(actividad_actual)-1][int(actividad_destino)-1]
                proxima_actividad = actividad_destino


    else:
      for actividad_destino in transiciones_validas:
        tau = feromonas[int(actividad_actual)-1][int(actividad_destino)-1]  # Cantidad de feromona
        eta = 1.0 / matriz_costos[int(actividad_actual)-1][int(actividad_destino)-1] if matriz_costos[int(actividad_actual)-1][int(actividad_destino)-1] != float('inf') else 0  # Valor heurístico. Puede ser inversamente proporcional al costo o a la distancia entre actividades.
        prob = (tau ** alpha) * (eta ** beta)
        probabilidades.append(prob)


      # Normalizar las probabilidades para que sumen 1
      probabilidades_normalizadas = [prob / sum(probabilidades) for prob in probabilidades]

      # Elegir la próxima actividad basada en las probabilidades calculadas
      indice_seleccionado = np.random.choice(range(len(transiciones_validas)), p=probabilidades_normalizadas)
      proxima_actividad = transiciones_validas[indice_seleccionado]


    actividades_validas.remove(proxima_actividad)

    return proxima_actividad, actividades_validas

import numpy as np
import time

# Utilizar la solución inicial para ajustar las feromonas
def ajustar_feromonas_iniciales(feromonas, solucion_inicial, calidad_inicial):
    for i in range(len(solucion_inicial) - 1):
        feromonas[solucion_inicial[i]-1][solucion_inicial[i+1]-1] += calidad_inicial  # Ajustar según la calidad de tu solución inicial
    return feromonas

# Función para generar la matriz de costos, teniendo en cuenta las restricciones
# actividades : Actividad	| Paciente	| Prioridad	| TR	| Recursos_Necesarios	| Tiempo
def generar_matriz_costos(actividades,orden_actividades_por_paciente):
    # Aquí debes implementar la lógica para generar los costos entre actividades,
    # respetando las restricciones de precedencia.
    num_actividades = len(actividades)
    matriz_costos = np.full((num_actividades, num_actividades), np.inf)  # Inicializa con infinito

    # Asignar costos en base a tiempo de ocupación y prioridad del paciente
    for i in range(num_actividades):
        for j in range(num_actividades):
            if i != j:  # Asegurarse de que no se esté calculando el costo de una actividad a sí misma
                # Restricciones de secuencia: Solo se consideran transiciones válidas
                if es_transicion_valida(actividades[i][:2], actividades[j][:2], orden_actividades_por_paciente):
                    # El costo podría ser inversamente proporcional a la prioridad del paciente
                    # y directamente proporcional al tiempo de la actividad
                    tiempo = actividades[j][5]  # Tiempo de la actividad destino
                    prioridad = actividades[j][2]  # Prioridad del paciente de la actividad destino
                    matriz_costos[i][j] = calcular_costo(tiempo, prioridad)

    return matriz_costos

def es_transicion_valida(actividad_origen, actividad_destino, orden_actividades_por_paciente):
    paciente_origen = actividad_origen[1]
    paciente_destino = actividad_destino[1]
    actividad_origen_id = actividad_origen[0]
    actividad_destino_id = actividad_destino[0]

    # Validación intra-paciente
    if paciente_origen == paciente_destino:
        indice_origen = orden_actividades_por_paciente[paciente_origen].index(actividad_origen_id)
        indice_destino = orden_actividades_por_paciente[paciente_destino].index(actividad_destino_id)
        return indice_destino == indice_origen + 1 # Devuelve true solo si es justo la actividad que precede a la de origen

    # Validación inter-paciente
    else:
      return True

# Calcular coste de ir a una actividad
def calcular_costo(tiempo, prioridad):
    # Asume que prioridades más altas tienen valores más bajos (1 es la máxima prioridad)
    # y que deseas minimizar tanto el tiempo de espera como atender primero a pacientes prioritarios.

    base_cost = 10  # Costo base para cualquier transición
    costo = base_cost + tiempo - (6-prioridad)
    return costo


def seleccionar_proxima_actividad(alpha, beta, q0, actividades_validas, actividades, feromonas, matriz_costos, orden_actividades_por_paciente, actividades_seleccionadas_por_hormiga):

    if not actividades_validas:
        return None, actividades_validas

    actividad_actual = actividades_seleccionadas_por_hormiga[-1]
    transiciones_validas = []

    for actividad_destino in actividades_validas:
        # Verificar que todas las actividades previas del paciente asociado a esta actividad se hayan completado
        for a in actividades:
          if actividad_destino == a[0]:
            paciente_destino = a[1] # queremos saber el paciente al cual pertenece esa actividad para poder comprobar que se cumple el orden de actividades
            break

        actividades_previas = orden_actividades_por_paciente[paciente_destino][:orden_actividades_por_paciente[paciente_destino].index(actividad_destino)]

        if all(actividad_previa in actividades_seleccionadas_por_hormiga for actividad_previa in actividades_previas):
          transiciones_validas.append(actividad_destino)

    if not transiciones_validas:  # Si no hay transiciones válidas
        return None, actividades_validas

    # Decision de explotación vs exploración
    if random.random() < q0:
        # Explotación: elegir el mejor basado en feromonas y costo (heurística)
        mejor_costo = 0
        seleccionado = None

        for actividad_destino in transiciones_validas:
            tau = feromonas[int(actividad_actual)-1][int(actividad_destino)-1]  # Cantidad de feromona
            costo= matriz_costos[int(actividad_actual)-1][int(actividad_destino)-1] # Valor costo
            eta = 1 / costo if costo != float('inf') else 0  # Inversa del costo como heurística

            # Utilizamos un producto de feromonas y heurística, buscando el máximo
            valor = (tau ** alpha) * (eta ** beta)
            if valor > mejor_costo:
                mejor_costo = valor
                seleccionado = actividad_destino

        actividades_validas.remove(seleccionado)
        return seleccionado, actividades_validas
    else:
        # Exploración: elegir basado en una distribución de probabilidades proporcional a feromonas y heurística
        probabilidades = []
        for actividad_destino in transiciones_validas:
            tau = feromonas[int(actividad_actual)-1][int(actividad_destino)-1]  # Cantidad de feromona
            costo= matriz_costos[int(actividad_actual)-1][int(actividad_destino)-1] # Valor costo
            eta = 1 / costo if costo != float('inf') else 0

            probabilidades.append((tau ** alpha) * (eta ** beta))

        # Normalizar las probabilidades
        suma_probabilidades = sum(probabilidades)
        if suma_probabilidades == 0:
            return None, actividades_validas  # En caso de que todas las probabilidades sean 0

        probabilidades_normalizadas = [prob / suma_probabilidades for prob in probabilidades]
        seleccionado = np.random.choice(transiciones_validas, p=probabilidades_normalizadas)
        actividades_validas.remove(seleccionado)
        return seleccionado, actividades_validas

def generar_solucion_hormiga(best_sol_i, feromonas, matriz_costos,orden_actividades_por_paciente, actividades, actividad_inicial,alpha, beta, q0):

  # Elegir una actividad de inicio (puede ser parte de la solución inicial dada)
  actividades_seleccionadas_por_hormiga = []
  actividades_seleccionadas_por_hormiga.append(actividad_inicial)
  actividades_validas = copy.copy(best_sol_i)
  actividades_validas.remove(actividad_inicial)

  # Mientras que la solución no esté completa
  while len(actividades_seleccionadas_por_hormiga) < len(best_sol_i):
            prox_actividad, actividades_validas = seleccionar_proxima_actividad(alpha, beta, q0,actividades_validas, actividades, feromonas, matriz_costos, orden_actividades_por_paciente, actividades_seleccionadas_por_hormiga)
            actividades_seleccionadas_por_hormiga.append(prox_actividad)

  return actividades_seleccionadas_por_hormiga
# Actualización de feromonas
def actualizar_feromonas(matriz_feromonas, soluciones_hormigas, calidad_soluciones, evaporacion):
    """
    Actualiza la matriz de feromonas basada en las soluciones encontradas por las hormigas y su calidad.

    Parámetros:
    - matriz_feromonas: Matriz de feromonas actual.
    - soluciones_hormigas: Lista de soluciones encontradas por las hormigas.
    - calidad_soluciones: Lista con un valor representativo de la calidad de cada solución.
    - evaporacion: Tasa de evaporación de la feromona.
    """
    # Evaporación de feromonas
    matriz_feromonas *= (1 - evaporacion)

    # Refuerzo de feromonas basado en la calidad de las soluciones
    #for solucion, calidad in zip(soluciones_hormigas, calidad_soluciones):
    for i in range(len(soluciones_hormigas)-1):
            # Aumentar las feromonas basado en la calidad de la solución
            matriz_feromonas[soluciones_hormigas[i]-1][soluciones_hormigas[i+1]-1] += calidad_soluciones

    return matriz_feromonas

def calcular_calidad_solucion(FO_decoding):
    """
    Calcula la calidad de una solución basada en el inverso del tiempo total.
    Valor representativo de la calidad de la solución. Soluciones con menor tiempo total tendrán una calidad mayor.
    """
    if FO_decoding > 0:
        return 100 / FO_decoding
    else:
        return float('inf')  # En caso de que tiempo_total sea 0, lo cual es improbable en escenarios reales.

# Algoritmo principal
def algoritmo_aco(num_hormigas, parametros ,Q_0, FO_inicial, solucion_inicial, actividades, orden_actividades_por_paciente, df_pacientes, df_recursos_final, df_datos,array_pacientes):
    # Inicializar parametros
    num_actividades = len(actividades)  # Ajustar según tu caso

    alpha = parametros[0] # Influencia de la feromona
    beta = parametros [1] # Influencia de la información heurística
    evaporacion = parametros[2] # Tasa de evaporación de la feromona
    q0 = Q_0
    feromonas = np.ones((num_actividades, num_actividades))
    best_hormiga = []
    best_hormiga_calidad = []
    best_hormiga_FO = []
    # Crear un DataFrame vacío
    df = pd.DataFrame(columns=['Iteracion','FO'])
    # Inicializar las feromonas según solución inicial
    coste_inicial= calcular_calidad_solucion(FO_inicial)
    feromonas = ajustar_feromonas_iniciales(feromonas, solucion_inicial, coste_inicial)
    matriz_costo = generar_matriz_costos(actividades,orden_actividades_por_paciente)
    best_hormiga.append(solucion_inicial)
    best_hormiga_calidad.append(coste_inicial)
    best_sol_i = solucion_inicial # ACO 2 Y 3
    tiempo_inicial = time.time()

    iteracion = 0
    #for iteracion in range(num_iteraciones): # Poner que pare en tiempo y en iteraciones ( con pacientes llegará a convergir mas rapido )
    while (time.time() - tiempo_inicial) <900:
        iteracion += 1

        soluciones_hormigas = []
        calidad_soluciones = []
        FO_soluciones = []
        tiempo_cero = time.time()
        # Generar soluciones para cada hormiga
        for hormiga in range(num_hormigas):
            paciente_inicial = np.random.choice(range(1,len(orden_actividades_por_paciente)))
            actividad_inicial = orden_actividades_por_paciente[paciente_inicial][0] # ACO 2
            #actividad_inicial = best_sol_i[0] # ACO 3
            #actividad_inicial = solucion_inicial[0] # ACO 1

            solucion_hormiga = generar_solucion_hormiga(best_sol_i, feromonas, matriz_costo, orden_actividades_por_paciente, actividades, actividad_inicial,alpha, beta, q0)
            FO_hormiga, df_datos_unido, df_pacientes = ejecuta_decoding(solucion_hormiga, array_prioridades, df_pacientes, df_recursos_final, df_datos)  # Implementar evaluación de la solución. Calcular su FO
            soluciones_hormigas.append(solucion_hormiga)
            calidad_soluciones.append(calcular_calidad_solucion(FO_hormiga))  # Implementar evaluación de la solución
            FO_soluciones.append(FO_hormiga)
            #print(calcular_calidad_solucion(FO_hormiga))

        # Actualizar feromonas
        tiempo_fin = time.time()
        #indice_best_hormiga = calidad_soluciones.index(max(calidad_soluciones))
        indice_best_hormiga = FO_soluciones.index(min(FO_soluciones))
        best_hormiga.append(soluciones_hormigas[indice_best_hormiga]) # Guardamos la mejor solucion de esta vuelta
        best_hormiga_calidad.append(calidad_soluciones[indice_best_hormiga])
        best_hormiga_FO.append(FO_soluciones[indice_best_hormiga])
        feromonas = actualizar_feromonas(feromonas, soluciones_hormigas[indice_best_hormiga], calidad_soluciones[indice_best_hormiga], evaporacion)

        best_sol_i = best_hormiga[best_hormiga_calidad.index(max(best_hormiga_calidad))] # Sirve solo en caso de lanzar ACO_3 (si no solo vale para saber las actividades que hay)
        # Agregar valores al DataFrame usando loc
        df.loc[len(df)] = [iteracion, FO_soluciones[indice_best_hormiga]]
        print(tiempo_fin - tiempo_cero)


    best_sol = best_hormiga[best_hormiga_FO.index(min(best_hormiga_FO))]
    FO_best = min(best_hormiga_FO)
    return best_sol, df, FO_best

actividades = df_datos.values.tolist() # Actividad	Paciente	Prioridad	TR	Recursos_Necesarios	Tiempo
len(actividades)

"""### Resultados ACO 1"""

# Parametros ajustados segun literatura
# Alpha: Influencia de la feromona en la probabilidad de seleccionar un camino.
 # Un valor de α más alto hace que la ruta con mayor feromona sea mucho más preferida,
 # promoviendo una exploración más intensiva de las rutas existentes.


# Beta :Influencia de la información heurística (p. ej., el inverso del costo que este depende el tiempo y prioridad).
  # Un valor más alto para β hace que las decisiones se basen más en la heurística,
  # promoviendo la exploración de caminos que parecen prometedores según esta información.

q0 = [0.4]
parametros = [2,0.5, 0.2] # alpha, beta, evaporacion
# Parametros a calibrar
num_hormigas = [1000]


actividades = df_datos.values.tolist() # Actividad	Paciente	Prioridad	TR	Recursos_Necesarios	Tiempo
results = pd.DataFrame(columns=['q0', 'num_hormigas', 'mejor_calidad', 'Iteración optima'])
for i in q0:
  for j in num_hormigas:
    best_sol , df , FO_ACO1 = algoritmo_aco(j, parametros,i, FO_inicial_1, rep_solucion_1, actividades, orden_actividades_por_paciente, df_pacientes, df_recursos_final, df_datos,array_pacientes)
    #FO_ACO1, df_datos_unido, df_pacientes = ejecuta_decoding(best_sol,array_prioridades , df_pacientes, df_recursos_final, df_datos)
    for index, row in df.iterrows():
      if row['FO'] == FO_ACO1:
          tiempo_promedio =(df.loc[index,'Iteracion'])
          break
      elif FO_inicial_1 == FO_ACO1:
          tiempo_promedio = 0

    results.loc[len(results)] = [i, j, FO_ACO1, tiempo_promedio]
    print(results)
    print(df)

    plt.figure(figsize=(10, 6))
    plt.plot(df['Iteracion'], df['FO'], marker='o')
    plt.title('Mejores soluciones encontradas por iteración')
    plt.xlabel('Iteración')
    plt.ylabel('FO')
    plt.legend()
    plt.grid(True)
    plt.show()

FO_ACO1

results

# Guardamos datos de prueba
import json
results.to_csv('results.csv', index=False)

FO_inicial_1

"""### Resultados ACO 2"""

# Parametros ajustados segun literatura
# Alpha: Influencia de la feromona en la probabilidad de seleccionar un camino.
 # Un valor de α más alto hace que la ruta con mayor feromona sea mucho más preferida,
 # promoviendo una exploración más intensiva de las rutas existentes.


# Beta :Influencia de la información heurística (p. ej., el inverso del costo que este depende el tiempo y prioridad).
  # Un valor más alto para β hace que las decisiones se basen más en la heurística,
  # promoviendo la exploración de caminos que parecen prometedores según esta información.
q0 = [0.4]
parametros = [2,0.5, 0.2] # alpha, beta, evaporacion
# Parametros a calibrar
num_hormigas = [75, 100, 150, 200, 300]
numero_de_iteraciones = 60

actividades = df_datos.values.tolist() # Actividad	Paciente	Prioridad	TR	Recursos_Necesarios	Tiempo
results = pd.DataFrame(columns=['q0', 'num_hormigas', 'mejor_calidad', 'Iteración optima'])
for i in q0:
  for j in num_hormigas:
    best_sol , df, FO_ACO1 = algoritmo_aco(j, parametros,i, FO_inicial_1, rep_solucion_1, actividades, orden_actividades_por_paciente, df_pacientes, df_recursos_final, df_datos)
    #FO_ACO1, df_datos_unido, df_pacientes = ejecuta_decoding(best_sol,array_prioridades , df_pacientes, df_recursos_final, df_datos)
    for index, row in df.iterrows():
      if row['FO'] == FO_ACO1:
          tiempo_promedio =(df.loc[index,'Iteracion'])
          break

    results.loc[len(results)] = [i, j, FO_ACO1, tiempo_promedio]
    print(results)
    print(df)

    plt.figure(figsize=(10, 6))
    plt.plot(df['Iteracion'], df['FO'], marker='o')
    plt.title('Mejores soluciones encontradas por iteración')
    plt.xlabel('Iteración')
    plt.ylabel('FO')
    plt.legend()
    plt.grid(True)
    plt.show()

# Establece un diccionario de colores para asegurarnos de que cada 'ro' tenga un color diferente
colores = {0.4: 'blue', 0.6: 'orange', 0.8: 'green', 0.9: 'red'}

plt.figure(figsize=(10, 6))

for q0, color in colores.items():
  # Filtra el DataFrame por el valor actual de 'ro'
  results_filtrado = results[results['q0'] == q0]
  # Suponiendo que 'N_HORMIGAS' es único en el DataFrame filtrado para cada 'ro'
  plt.plot(results_filtrado['num_hormigas'], results_filtrado['mejor_calidad'], marker='o', color=color, label=f'q0 = {q0}')

plt.title('best_FO vs. N_HORMIGAS para diferentes valores de q0')
plt.xlabel('numero de hormigas')
plt.ylabel('FO')
plt.legend()
plt.grid(True)
plt.show()

results

# Guardamos datos de prueba
import json
results.to_csv('results.csv', index=False)

"""### Resultados ACO 3"""

# Parametros ajustados segun literatura
# Alpha: Influencia de la feromona en la probabilidad de seleccionar un camino.
 # Un valor de α más alto hace que la ruta con mayor feromona sea mucho más preferida,
 # promoviendo una exploración más intensiva de las rutas existentes.


# Beta :Influencia de la información heurística (p. ej., el inverso del costo que este depende el tiempo y prioridad).
  # Un valor más alto para β hace que las decisiones se basen más en la heurística,
  # promoviendo la exploración de caminos que parecen prometedores según esta información.
q0 = [0.4, 0.6, 0.8, 0.9]
parametros = [2,0.5, 0.2] # alpha, beta, evaporacion
# Parametros a calibrar
num_hormigas = [50, 100, 500, 1000]


actividades = df_datos.values.tolist() # Actividad	Paciente	Prioridad	TR	Recursos_Necesarios	Tiempo
results = pd.DataFrame(columns=['q0', 'num_hormigas', 'mejor_calidad', 'Iteración optima'])
for i in q0:
  for j in num_hormigas:
    best_sol , df , FO_ACO1= algoritmo_aco(j, parametros,i, FO_inicial_1, rep_solucion_1, actividades, orden_actividades_por_paciente, df_pacientes, df_recursos_final, df_datos)
    #FO_ACO1, df_datos_unido, df_pacientes = ejecuta_decoding(best_sol,array_prioridades , df_pacientes, df_recursos_final, df_datos)
    for index, row in df.iterrows():
      if row['FO'] == FO_ACO1:
          tiempo_promedio =(df.loc[index,'Iteracion'])
          break

    results.loc[len(results)] = [i, j, FO_ACO1, tiempo_promedio]
    print(results)
    print(df)

    plt.figure(figsize=(10, 6))
    plt.plot(df['Iteracion'], df['FO'], marker='o')
    plt.title('Mejores soluciones encontradas por iteración')
    plt.xlabel('Iteración')
    plt.ylabel('FO')
    plt.legend()
    plt.grid(True)
    plt.show()

# Establece un diccionario de colores para asegurarnos de que cada 'ro' tenga un color diferente
colores = {0.4: 'blue', 0.6: 'orange', 0.8: 'green', 0.9: 'red'}

plt.figure(figsize=(10, 6))

for q0, color in colores.items():
  # Filtra el DataFrame por el valor actual de 'ro'
  results_filtrado = results[results['q0'] == q0]
  # Suponiendo que 'N_HORMIGAS' es único en el DataFrame filtrado para cada 'ro'
  plt.plot(results_filtrado['num_hormigas'], results_filtrado['mejor_calidad'], marker='o', color=color, label=f'q0 = {q0}')

plt.title('best_FO vs. N_HORMIGAS para diferentes valores de q0')
plt.xlabel('numero de hormigas')
plt.ylabel('FO')
plt.legend()
plt.grid(True)
plt.show()

# Guardamos datos de prueba
import json
results.to_csv('results.csv', index=False)

FO_inicial_1

"""# Algoritmo colonia de hormigas por pacientes"""

def ejecuta_decoding_pacientes(df_datos ,df_pacientes, solucion):
  # Diccionarios (clave: valor) para mayor legibilidad de los resultados
  tiempo_inicio_actividad={}
  tiempos_finalizacion_actividad={}
  consultas_asignadas = {}
  recurso_asignado={}

  # Inicializamos las consultas asignadas a cada paciente
  for i in range(len(solucion)):
    consultas_asignadas[i+1] = 0 # paciente 1: CON1, paciente 2: CON2 ...

  # Organizamos las actividades en función del orden establecido por la hormiga
  matriz_actividades = df_datos.groupby('Paciente')['Actividad'].apply(list).reindex(solucion).tolist() # solucion = [2, 1, 3, 4]
  # Obtener la longitud máxima de las sublistas en Pu_ordenado
  longitud_maxima = max(map(len, matriz_actividades))
  # Rellenar con ceros las sublistas que no llegan al máximo para poder transponerla sin perder actividades
  Pu_transpuesto = [sublista + ['0'] * (longitud_maxima - len(sublista)) for sublista in matriz_actividades]

  # Transponer la lista resultante
  Pu_transpuesto = list(map(list, zip(*Pu_transpuesto)))
  # Obtenemos la matriz de Pu sin los ceros
  rep_solucion = []
  for i in Pu_transpuesto:
    for j in i:
      if j!='0':
        rep_solucion.append(j)

    # Seleccionar las columnas de interés
  columna_clave = 'Paciente'
  columna_valor = 't_disponible'

    # Crear el diccionario
  tiempo_final_paciente = df_pacientes.set_index(columna_clave)[columna_valor].to_dict()

    # Seleccionar las columnas de interés
  columna_clave2 = 'recurso'
  columna_valor2 = 't_disponible'

    # Crear el diccionario
  tiempo_final_recurso = df_recursos_final.set_index(columna_clave2)[columna_valor2].to_dict()

  ## Bucle que organiza actividades en orden de la solucion
  for actividad in rep_solucion:
        # ¿Qué tipo de recurso necesita la actividad?
        indice = df_datos.loc[df_datos['Actividad'] == actividad].index.item()
        paciente, tipo, cantidad_recurso_actividad, tiempo_actividad = df_datos.loc[indice,['Paciente','TR','Recursos_Necesarios','Tiempo']]
        tiempo_p = tiempo_final_paciente.get(paciente,0)

        asigna_recurso(TR, R, CR, tipo, actividad ,tiempo_p, tiempo_actividad, paciente, cantidad_recurso_actividad, tiempo_final_recurso, tiempo_final_paciente, consultas_asignadas,tiempos_finalizacion_actividad,tiempo_inicio_actividad, recurso_asignado)


  #####################################################################################
  ### Calcula TEPCOF:

  data_list = []
  for key, value in tiempos_finalizacion_actividad.items():
          data_list.append({'Actividad': key, 'Recurso_asignado': recurso_asignado[key],'Tiempo_inicio':tiempo_inicio_actividad[key], 'Tiempo_FIN': value})

      # Crear un DataFrame a partir de la lista de diccionarios
  Data_pacientes = pd.DataFrame(data_list)
  df_datos_unido = pd.merge(df_datos, Data_pacientes, on='Actividad', how='inner')

      # Itera sobre las filas del DataFrame
  for index1, row1 in df_pacientes.iterrows():
        tiempo_primera_actividad = 1000
        if row1['visto'] == 0:
          a = row1['Paciente']
          b = row1['t_llegada']
          # Guardamos el tiempo de su primera actividad (el tiempo de inicio mas pequeño)
          for index2, row2 in df_datos_unido.iterrows():
            if row2['Paciente'] == a:
              t_inicio = df_datos_unido.loc[index2,'Tiempo_inicio']
              if t_inicio < tiempo_primera_actividad:
                tiempo_primera_actividad = t_inicio

          calculo = tiempo_primera_actividad + b
        else:
          calculo = None


        # Añadimos el dato en una nueva columna, en el indice correspondiente del primer DataFrame

        df_pacientes.at[index1, 'TEPCOF_real'] = calculo

  #### Calcula FO
  FO=FO_solucion(df_pacientes, tiempo_final_paciente)
  #representa_GANTT(df_datos_unido)
  return FO, df_pacientes, df_datos_unido
  ###############################################################

import time
import matplotlib.pyplot as plt

# Utilizar la solución inicial para ajustar las feromonas
def ajustar_feromonas_iniciales(feromonas, solucion_inicial, coste_inicial):
    for i in range(len(solucion_inicial) - 1):
        feromonas[solucion_inicial[i]-1][solucion_inicial[i+1]-1] += coste_inicial  # Ajustar según la calidad de tu solución inicial
    return feromonas

# Función para generar la matriz de costos - EN ESTE CASO NO HAY RESTRICCIONES DE PRECEDENCIA
# actividades : Actividad	| Paciente	| Prioridad	| TR	| Recursos_Necesarios	| Tiempo
def generar_matriz_costos(df_pacientes):
    n_pacientes = len(df_pacientes)  # Número de pacientes
    matriz_costos = np.full((n_pacientes, n_pacientes), np.inf)  # Inicializa la matriz de costos

    # Calcula el costo de transición de cada paciente a todos los demás
    for i in range(n_pacientes):
        for j in range(n_pacientes):
            if i != j:  # Asegura que no se calcule el costo de un paciente a sí mismo
                prioridad_j = df_pacientes.at[j,'Prioridad']
                visto_j = df_pacientes.at[j, 'visto']
                # Calcula el costo según la prioridad y si ha sido visto
                costo = (1 / (6 - prioridad_j)) * (1 - 0.2 * visto_j)
                matriz_costos[i][j] = costo

    return matriz_costos


# Selección de el proximo paciente
def seleccionar_proximo_paciente_1(pacientes_seleccionados_por_hormiga, matriz_feromonas, matriz_costos, alpha, beta, q0):
    ultimo_paciente = pacientes_seleccionados_por_hormiga[-1]
    candidatos = [i for i in range(len(matriz_costos)) if i not in pacientes_seleccionados_por_hormiga]
    probabilidades = []

    if random.random() < q0:  # Explotación: selecciona el mejor candidato con alta probabilidad q0
        mejor_costo = 0
        seleccionado = None
        for candidato in candidatos:
            # Considera la inversa del costo por la cantidad de feromona para encontrar el 'mejor' camino
            tau = matriz_feromonas[ultimo_paciente][candidato]  # Intensidad de la feromona
            costo = matriz_costos[ultimo_paciente][candidato]
            eta = 1 / costo if costo != float('inf') else 0  # Inversa del costo como heurística
            # Utilizamos un producto de feromonas y heurística, buscando el máximo
            valor = (tau ** alpha) * (eta ** beta)

            if valor > mejor_costo:
                mejor_costo = valor
                seleccionado = candidato

    else:  # Exploración: selecciona un candidato basado en una distribución de probabilidad
      for candidato in candidatos:
        tau = matriz_feromonas[ultimo_paciente][candidato]
        eta = 1/matriz_costos[ultimo_paciente][candidato]
        probabilidades.append((tau ** alpha) * (eta ** beta))

      suma_probabilidades = sum(probabilidades)
      probabilidades_normalizadas = [p/suma_probabilidades for p in probabilidades]
      # Selecciona un candidato de manera aleatoria ponderada por las probabilidades normalizadas
      seleccionado = random.choices(candidatos, weights=probabilidades_normalizadas, k=1)[0]

    return seleccionado

# Actualización de feromonas
def actualizar_feromonas(matriz_feromonas, solucion, calidad, tasa_evaporacion):

    # Evaporación de feromonas
      # Evaporación de feromonas
    for i in range(len(matriz_feromonas)):
      for j in range(len(matriz_feromonas)):
        matriz_feromonas[i][j] *= (1 - tasa_evaporacion)

    # Refuerzo de feromonas para cada solución encontrada por las hormigas
    #for solucion, calidad in zip(soluciones, calidad_soluciones):
    for i in range(len(solucion)-1):
            # Aumentar las feromonas basado en la calidad de la solución
           matriz_feromonas[solucion[i]-1][solucion[i+1]-1] += calidad

    return matriz_feromonas



######## NO LA USO PORQUE DIRECTAMENTE CALCULO LA CALIDAD CON EL VALOR DE FO!!!
def calcular_calidad_solucion(FO_decoding):
    """
    Calcula la calidad de una solución basada en el inverso del tiempo total.

    Parámetros:
    - FO_decoding: Función objetivo. El tiempo total que los pacientes se encuentran en el hospital según la solución actual.

    Retorna:
    - Un valor representativo de la calidad de la solución. Soluciones con menor tiempo total tendrán una calidad mayor.
    """
    if FO_decoding > 0:
        return 100 / FO_decoding
    else:
        return float('inf')  # En caso de que tiempo_total sea 0, lo cual es improbable en escenarios reales.
################


# Algoritmo principal
def algoritmo_aco_pacientes(FO_inicial,solucion_inicial, num_hormigas, df_pacientes ,df_datos, alpha, beta, ro,q0):
    semilla = 0
    num_pacientes = len(df_pacientes)
    # Inicialización de la matriz de feromonas
    matriz_feromonas = [[1 for _ in range(num_pacientes)] for _ in range(num_pacientes)]
    # Inicializamos feromonas según la solución inicial
    calidad_inicial = calcular_calidad_solucion(FO_inicial)
    feromonas = ajustar_feromonas_iniciales(matriz_feromonas, solucion_inicial, calidad_inicial)
    matriz_costos = generar_matriz_costos(df_pacientes)  # Suponiendo que ya tienes una lista 'pacientes' definida
    mejor_solucion = []
    mejor_solucion_calidad = []
    mejor_solucion_FO = []
    tiempo_inicial = time.time()
    # Crear un DataFrame vacío
    df = pd.DataFrame(columns=['Iteracion','FO'])
    iteracion = 0

    #for iteracion in range(num_iteraciones): # Poner que pare en tiempo y en iteraciones ( con pacientes llegará a convergir mas rapido )
    while (time.time() - tiempo_inicial) < 42.1875:
        soluciones = []  # Lista para almacenar las soluciones de esta iteración
        calidad_soluciones = []
        FO_soluciones = []
        iteracion += 1
        for n in range(num_hormigas):
            pacientes_seleccionados_por_hormiga = [random.randint(0, num_pacientes-1)]  # Inicia con un paciente aleatorio
            #print('primer paciente:',pacientes_seleccionados_por_hormiga)
            while len(pacientes_seleccionados_por_hormiga) < num_pacientes:
                proximo_paciente = seleccionar_proximo_paciente_1(pacientes_seleccionados_por_hormiga, matriz_feromonas, matriz_costos, alpha, beta, q0) #pacientes_seleccionados_por_hormiga, matriz_feromonas, matriz_costos, alpha, beta, q0
                pacientes_seleccionados_por_hormiga.append(proximo_paciente)

            # Calcula el costo de la solución encontrada (en función de la FO)
            pacientes_seleccionados_por_hormiga = [x + 1 for x in pacientes_seleccionados_por_hormiga]
            FO_hormiga, df_pacientes, df_datos_unido = ejecuta_decoding_pacientes(df_datos ,df_pacientes, pacientes_seleccionados_por_hormiga)  # Implementar evaluación de la solución. Calcular su FO
            soluciones.append(pacientes_seleccionados_por_hormiga)
            calidad_soluciones.append(calcular_calidad_solucion(FO_hormiga))  # Implementar evaluación de la solución
            FO_soluciones.append(FO_hormiga)


        # Opcional: Imprimir el mejor camino y su costo de la iteración
        #indice_mejor_hormiga = calidad_soluciones.index(max(calidad_soluciones))
        indice_mejor_hormiga = FO_soluciones.index(min(FO_soluciones))
        mejor_solucion.append(soluciones[indice_mejor_hormiga])
        mejor_solucion_calidad.append(calidad_soluciones[indice_mejor_hormiga])
        mejor_solucion_FO.append(FO_soluciones[indice_mejor_hormiga])
        df.loc[len(df)] = [iteracion, FO_soluciones[indice_mejor_hormiga]]

         # Actualiza la matriz de feromonas con la mejor solucion encontrada
        matriz_feromonas = actualizar_feromonas(matriz_feromonas, soluciones[indice_mejor_hormiga], calidad_soluciones[indice_mejor_hormiga],ro)

    # Devuelve el mejor camino y su costo después de todas las iteraciones
    #mejor_solucion_global = mejor_solucion[mejor_solucion_calidad.index(max(mejor_solucion_calidad))]
    mejor_solucion_global = mejor_solucion[mejor_solucion_FO.index(min(mejor_solucion_FO))]
    mejor_FO = min(mejor_solucion_FO)
    return mejor_solucion_global, df, mejor_FO

q0 = [0.4, 0.6, 0.8, 0.9]
alpha = 2  # Influencia de la feromona
beta = 0.5  # Influencia de la información heurística
tasa_evaporacion = 0.2
# Parametros a calibrar
num_hormigas = [50, 100, 500, 1000]

solucion_inicial = array_pacientes
df_pacientes = df_pacientes.sort_values(by='Paciente')


results = pd.DataFrame(columns=['q0', 'num_hormigas', 'mejor_calidad', 'Iteración optima'])
for i in q0:
  for j in num_hormigas:
    best_sol, df, FO_ACO2 = algoritmo_aco_pacientes(FO_inicial_1,solucion_inicial, j, df_pacientes ,df_datos, alpha, beta, tasa_evaporacion,i)
    #FO_ACO2, df_pacientes, df_datos_unido = ejecuta_decoding_pacientes(df_datos ,df_pacientes, best_sol)
    for index, row in df.iterrows():
      if row['FO'] == FO_ACO2:
          tiempo_promedio =(df.loc[index,'Iteracion'])
          break

    results.loc[len(results)] = [i, j, FO_ACO2, tiempo_promedio]
    print(results)
    print(df)

    plt.figure(figsize=(10, 6))
    plt.plot(df['Iteracion'], df['FO'], marker='o')
    plt.title('Mejores soluciones encontradas por iteración')
    plt.xlabel('Iteración')
    plt.ylabel('FO')
    plt.legend()
    plt.grid(True)
    plt.show()

# Establece un diccionario de colores para asegurarnos de que cada 'ro' tenga un color diferente
colores = {0.4: 'blue', 0.6: 'orange', 0.8: 'green', 0.9: 'red'}

plt.figure(figsize=(10, 6))

for q0, color in colores.items():
  # Filtra el DataFrame por el valor actual de 'ro'
  results_filtrado = results[results['q0'] == q0]
  # Suponiendo que 'N_HORMIGAS' es único en el DataFrame filtrado para cada 'ro'
  plt.plot(results_filtrado['num_hormigas'], results_filtrado['mejor_calidad'], marker='o', color=color, label=f'q0 = {q0}')

plt.title('best_FO vs. N_HORMIGAS para diferentes valores de q0')
plt.xlabel('numero de hormigas')
plt.ylabel('FO')
plt.legend()
plt.grid(True)
plt.show()

results

# Guardamos datos de prueba
import json
results.to_csv('results.csv', index=False)