# -*- coding: utf-8 -*-
"""main.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1B9JADGwVQ7ZKUu5u7RseqNSzXouJbM7a
"""

from config import PARAMS
from constantes import procesos_por_prioridad, TEPCOF, TR, R, CR
from src.generador import establece_prioridad, generar_pacientes_y_recursos
from src.acciones import calcula_saturacion, ejecuta_decoding, ejecuta_decoding_pacientes
from src.meteheurísticas_busquedalocal import (
  algoritmo_aco1_bl, algoritmo_aco2_bl,
  algoritmo_aco3_bl, algoritmo_aco_bl_pacientes
)
from src.meteheurísticas import (
  algoritmo_aco1, algoritmo_aco2,
  algoritmo_aco3, algoritmo_aco_pacientes,
)
from src.visualizaciones import representa_GANTT

import pandas as pd
import numpy as np
import random

# -----------------------------------
# Generación de pacientes hasta saturación deseada
# -----------------------------------

if __name__ == '__main__':
  random.seed(PARAMS["seed"])  # Fijar semilla para reproducibilidad
  np.random.seed(PARAMS["seed"])  # Fijar semilla para reproducibilidad
  # 1. Inicialización hasta alcanzar la saturación deseada del SUH
  I = 0
  flag = 0

  while flag == 0:
      I += 1

      # Paso 1: generar prioridades para I pacientes
      prioridades = establece_prioridad(I, 5)

      # Paso 2: generar todos los datos a partir de las prioridades
      df_pacientes, df_recursos_final, recursos, df_datos, df_recursos_ocupados, orden_actividades_por_paciente = generar_pacientes_y_recursos(prioridades, procesos_por_prioridad, TEPCOF, TR, R)
      
      # Paso 3: comprobar saturación
      flag, df_saturacion = calcula_saturacion(df_datos, df_recursos_ocupados, PARAMS["nivel_saturacion"], TR)
  
  print(df_saturacion)
  print(df_datos)
  print(df_pacientes)
  print(df_recursos_ocupados)

  # 2. Generar solución inicial con una heurística constructiva

  array_pacientes = df_pacientes['Paciente'].values

  # Agrupar actividades por paciente
  matriz_actividades = df_datos.groupby('Paciente')['Actividad'].apply(list).reindex(array_pacientes).tolist()

  # Obtener la longitud máxima de las sublistas en Pu_ordenado
  longitud_maxima = max(map(len, matriz_actividades))

  # Rellenar con ceros las sublistas que no llegan al máximo para poder transponerla sin perder actividades
  Pu_transpuesto = [sublista + ['0'] * (longitud_maxima - len(sublista)) for sublista in matriz_actividades]

  # Transponer la lista resultante
  Pu_transpuesto = list(map(list, zip(*Pu_transpuesto)))

  # Obtenemos la matriz de Pu sin los ceros
  rep_solucion_1 = []
  for i in Pu_transpuesto:
    for j in i:
      if j!='0':
        rep_solucion_1.append(j)

  FO_inicial_1, df_datos_unido, df_pacientes = ejecuta_decoding(rep_solucion_1, df_pacientes, df_recursos_final, df_datos,array_pacientes,TR, R, CR)

  print(f"Función objetivo inicial: {FO_inicial_1}")
  representa_GANTT(df_datos_unido)

  actividades = df_datos.values.tolist() # Actividad	Paciente	Prioridad	TR	Recursos_Necesarios	Tiempo
  results = pd.DataFrame(columns=['q0', 'num_hormigas', 'mejor_calidad', 'Iteración optima'])

  # 3. Extraer parámetros individuales
  parametros = [PARAMS["alpha"],PARAMS["beta"], PARAMS["evaporacion"]] # alpha, beta, evaporacion
  num_hormigas = PARAMS['num_hormigas']
  q01 = PARAMS['q0']
  tiempo_computacion = (((len(df_datos)*15) /2)*375)/1000 # a las 12h
  #tiempo_computacion = (((len(df_datos)*9) /2)*375)/1000 # a las 6h

  # 4. Ejecutar ACO
  if PARAMS["modo_bl"]==True:
    if PARAMS["aco_version"]==1:
      best_sol, df, FO_ACO_final, counter, df_datos_unido = algoritmo_aco1_bl(
                tiempo_computacion,
                array_pacientes,
                num_hormigas,
                parametros,
                q01,
                FO_inicial_1,
                rep_solucion_1,
                actividades,
                orden_actividades_por_paciente,
                df_pacientes,
                df_recursos_final,
                df_datos,
                TR, 
                R, 
                CR
            )
    elif PARAMS["aco_version"]==2:
      best_sol, df, FO_ACO_final, counter, df_datos_unido = algoritmo_aco2_bl(
                tiempo_computacion,
                array_pacientes,
                num_hormigas,
                parametros,
                q01,
                FO_inicial_1,
                rep_solucion_1,
                actividades,
                orden_actividades_por_paciente,
                df_pacientes,
                df_recursos_final,
                df_datos,
                TR, 
                R, 
                CR
            )
    elif PARAMS["aco_version"]==3:
      best_sol, df, FO_ACO_final, counter, df_datos_unido = algoritmo_aco3_bl(
                tiempo_computacion,
                array_pacientes,
                num_hormigas,
                parametros,
                q01,
                FO_inicial_1,
                rep_solucion_1,
                actividades,
                orden_actividades_por_paciente,
                df_pacientes,
                df_recursos_final,
                df_datos,
                TR, 
                R, 
                CR
            )
    elif PARAMS["aco_version"]==4:
      solucion_inicial = array_pacientes
      df_pacientes = df_pacientes.sort_values(by='Paciente')
      best_sol, df, FO_ACO_final, counter, df_datos_unido = algoritmo_aco_bl_pacientes(
                tiempo_computacion,
                array_pacientes,
                FO_inicial_1,
                solucion_inicial,
                num_hormigas,
                df_pacientes,
                df_recursos_final,
                df_datos, 
                PARAMS["alpha"],
                PARAMS["beta"],
                PARAMS["evaporacion"],
                PARAMS["q0"],
                TR, 
                R, 
                CR
            )
    else:
          print("Indique unicamente algoritmo 1,2,3 o 4 okkk")

  else:
    if PARAMS["aco_version"]==1:
      best_sol, df, FO_ACO_final, counter, df_datos_unido = algoritmo_aco1(
                tiempo_computacion,
                num_hormigas,
                parametros,
                q01,
                FO_inicial_1,
                rep_solucion_1,
                actividades,
                orden_actividades_por_paciente,
                df_pacientes,
                df_recursos_final,
                df_datos,
                array_pacientes,
                TR,
                R,
                CR
            )
    elif PARAMS["aco_version"]==2:
      best_sol, df, FO_ACO_final, counter, df_datos_unido = algoritmo_aco2(
                tiempo_computacion,
                num_hormigas,
                parametros,
                q01,
                FO_inicial_1,
                rep_solucion_1,
                actividades,
                orden_actividades_por_paciente,
                df_pacientes,
                df_recursos_final,
                df_datos,
                array_pacientes,
                TR,
                R,
                CR
            )
    elif PARAMS["aco_version"]==3:
      best_sol, df, FO_ACO_final, counter, df_datos_unido = algoritmo_aco3(
                tiempo_computacion,
                num_hormigas,
                parametros,
                q01,
                FO_inicial_1,
                rep_solucion_1,
                actividades,
                orden_actividades_por_paciente,
                df_pacientes,
                df_recursos_final,
                df_datos,
                array_pacientes,
                TR,
                R,
                CR
            )
    elif PARAMS["aco_version"]==4:
      solucion_inicial = array_pacientes
      print("Solución inicial:", solucion_inicial)
      df_pacientes = df_pacientes.sort_values(by='Paciente')
      best_sol, df, FO_ACO_final, df_datos_unido = algoritmo_aco_pacientes(
               FO_inicial_1,
               solucion_inicial,
               num_hormigas,
               df_pacientes,
               df_recursos_final,
               df_datos,
               PARAMS["alpha"],
               PARAMS["beta"],
               PARAMS["evaporacion"],
               PARAMS["q0"],
               TR,
               R,
               CR
            )
    else:
      print("Indique unicamente algoritmo 1,2,3 o 4.")

  print(f"FO Final ACO: {FO_ACO_final}")
  print(f"FO inicial ACO: {FO_inicial_1}")

  # 5. Visualización
  representa_GANTT(df_datos_unido)